
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Dataset
 * 
 */
export type Dataset = $Result.DefaultSelection<Prisma.$DatasetPayload>
/**
 * Model IngestionJob
 * 
 */
export type IngestionJob = $Result.DefaultSelection<Prisma.$IngestionJobPayload>
/**
 * Model Observation
 * 
 */
export type Observation = $Result.DefaultSelection<Prisma.$ObservationPayload>
/**
 * Model Shark
 * 
 */
export type Shark = $Result.DefaultSelection<Prisma.$SharkPayload>
/**
 * Model TrackingData
 * 
 */
export type TrackingData = $Result.DefaultSelection<Prisma.$TrackingDataPayload>
/**
 * Model SharkHotspot
 * 
 */
export type SharkHotspot = $Result.DefaultSelection<Prisma.$SharkHotspotPayload>
/**
 * Model SharkSeasonalStats
 * 
 */
export type SharkSeasonalStats = $Result.DefaultSelection<Prisma.$SharkSeasonalStatsPayload>
/**
 * Model MLModel
 * 
 */
export type MLModel = $Result.DefaultSelection<Prisma.$MLModelPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  SCIENTIST: 'SCIENTIST',
  PUBLIC: 'PUBLIC'
};

export type Role = (typeof Role)[keyof typeof Role]


export const DatasetStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type DatasetStatus = (typeof DatasetStatus)[keyof typeof DatasetStatus]


export const JobStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type DatasetStatus = $Enums.DatasetStatus

export const DatasetStatus: typeof $Enums.DatasetStatus

export type JobStatus = $Enums.JobStatus

export const JobStatus: typeof $Enums.JobStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataset`: Exposes CRUD operations for the **Dataset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Datasets
    * const datasets = await prisma.dataset.findMany()
    * ```
    */
  get dataset(): Prisma.DatasetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ingestionJob`: Exposes CRUD operations for the **IngestionJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngestionJobs
    * const ingestionJobs = await prisma.ingestionJob.findMany()
    * ```
    */
  get ingestionJob(): Prisma.IngestionJobDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.observation`: Exposes CRUD operations for the **Observation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Observations
    * const observations = await prisma.observation.findMany()
    * ```
    */
  get observation(): Prisma.ObservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shark`: Exposes CRUD operations for the **Shark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sharks
    * const sharks = await prisma.shark.findMany()
    * ```
    */
  get shark(): Prisma.SharkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trackingData`: Exposes CRUD operations for the **TrackingData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrackingData
    * const trackingData = await prisma.trackingData.findMany()
    * ```
    */
  get trackingData(): Prisma.TrackingDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharkHotspot`: Exposes CRUD operations for the **SharkHotspot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharkHotspots
    * const sharkHotspots = await prisma.sharkHotspot.findMany()
    * ```
    */
  get sharkHotspot(): Prisma.SharkHotspotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharkSeasonalStats`: Exposes CRUD operations for the **SharkSeasonalStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharkSeasonalStats
    * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findMany()
    * ```
    */
  get sharkSeasonalStats(): Prisma.SharkSeasonalStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mLModel`: Exposes CRUD operations for the **MLModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MLModels
    * const mLModels = await prisma.mLModel.findMany()
    * ```
    */
  get mLModel(): Prisma.MLModelDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ApiKey: 'ApiKey',
    Dataset: 'Dataset',
    IngestionJob: 'IngestionJob',
    Observation: 'Observation',
    Shark: 'Shark',
    TrackingData: 'TrackingData',
    SharkHotspot: 'SharkHotspot',
    SharkSeasonalStats: 'SharkSeasonalStats',
    MLModel: 'MLModel'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "apiKey" | "dataset" | "ingestionJob" | "observation" | "shark" | "trackingData" | "sharkHotspot" | "sharkSeasonalStats" | "mLModel"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Dataset: {
        payload: Prisma.$DatasetPayload<ExtArgs>
        fields: Prisma.DatasetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findFirst: {
            args: Prisma.DatasetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          findMany: {
            args: Prisma.DatasetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          create: {
            args: Prisma.DatasetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          createMany: {
            args: Prisma.DatasetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          delete: {
            args: Prisma.DatasetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          update: {
            args: Prisma.DatasetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          deleteMany: {
            args: Prisma.DatasetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatasetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>[]
          }
          upsert: {
            args: Prisma.DatasetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetPayload>
          }
          aggregate: {
            args: Prisma.DatasetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataset>
          }
          groupBy: {
            args: Prisma.DatasetGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetCountAggregateOutputType> | number
          }
        }
      }
      IngestionJob: {
        payload: Prisma.$IngestionJobPayload<ExtArgs>
        fields: Prisma.IngestionJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngestionJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngestionJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          findFirst: {
            args: Prisma.IngestionJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngestionJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          findMany: {
            args: Prisma.IngestionJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>[]
          }
          create: {
            args: Prisma.IngestionJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          createMany: {
            args: Prisma.IngestionJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngestionJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>[]
          }
          delete: {
            args: Prisma.IngestionJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          update: {
            args: Prisma.IngestionJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          deleteMany: {
            args: Prisma.IngestionJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngestionJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngestionJobUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>[]
          }
          upsert: {
            args: Prisma.IngestionJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngestionJobPayload>
          }
          aggregate: {
            args: Prisma.IngestionJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngestionJob>
          }
          groupBy: {
            args: Prisma.IngestionJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngestionJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngestionJobCountArgs<ExtArgs>
            result: $Utils.Optional<IngestionJobCountAggregateOutputType> | number
          }
        }
      }
      Observation: {
        payload: Prisma.$ObservationPayload<ExtArgs>
        fields: Prisma.ObservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findFirst: {
            args: Prisma.ObservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findMany: {
            args: Prisma.ObservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          create: {
            args: Prisma.ObservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          createMany: {
            args: Prisma.ObservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          delete: {
            args: Prisma.ObservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          update: {
            args: Prisma.ObservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          deleteMany: {
            args: Prisma.ObservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          upsert: {
            args: Prisma.ObservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          aggregate: {
            args: Prisma.ObservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservation>
          }
          groupBy: {
            args: Prisma.ObservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationCountAggregateOutputType> | number
          }
        }
      }
      Shark: {
        payload: Prisma.$SharkPayload<ExtArgs>
        fields: Prisma.SharkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          findFirst: {
            args: Prisma.SharkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          findMany: {
            args: Prisma.SharkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>[]
          }
          create: {
            args: Prisma.SharkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          createMany: {
            args: Prisma.SharkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>[]
          }
          delete: {
            args: Prisma.SharkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          update: {
            args: Prisma.SharkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          deleteMany: {
            args: Prisma.SharkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>[]
          }
          upsert: {
            args: Prisma.SharkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkPayload>
          }
          aggregate: {
            args: Prisma.SharkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShark>
          }
          groupBy: {
            args: Prisma.SharkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharkCountArgs<ExtArgs>
            result: $Utils.Optional<SharkCountAggregateOutputType> | number
          }
        }
      }
      TrackingData: {
        payload: Prisma.$TrackingDataPayload<ExtArgs>
        fields: Prisma.TrackingDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackingDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackingDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          findFirst: {
            args: Prisma.TrackingDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackingDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          findMany: {
            args: Prisma.TrackingDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>[]
          }
          create: {
            args: Prisma.TrackingDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          createMany: {
            args: Prisma.TrackingDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrackingDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>[]
          }
          delete: {
            args: Prisma.TrackingDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          update: {
            args: Prisma.TrackingDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          deleteMany: {
            args: Prisma.TrackingDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrackingDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrackingDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>[]
          }
          upsert: {
            args: Prisma.TrackingDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrackingDataPayload>
          }
          aggregate: {
            args: Prisma.TrackingDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackingData>
          }
          groupBy: {
            args: Prisma.TrackingDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackingDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrackingDataCountArgs<ExtArgs>
            result: $Utils.Optional<TrackingDataCountAggregateOutputType> | number
          }
        }
      }
      SharkHotspot: {
        payload: Prisma.$SharkHotspotPayload<ExtArgs>
        fields: Prisma.SharkHotspotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharkHotspotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharkHotspotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          findFirst: {
            args: Prisma.SharkHotspotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharkHotspotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          findMany: {
            args: Prisma.SharkHotspotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>[]
          }
          create: {
            args: Prisma.SharkHotspotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          createMany: {
            args: Prisma.SharkHotspotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharkHotspotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>[]
          }
          delete: {
            args: Prisma.SharkHotspotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          update: {
            args: Prisma.SharkHotspotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          deleteMany: {
            args: Prisma.SharkHotspotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharkHotspotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharkHotspotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>[]
          }
          upsert: {
            args: Prisma.SharkHotspotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkHotspotPayload>
          }
          aggregate: {
            args: Prisma.SharkHotspotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharkHotspot>
          }
          groupBy: {
            args: Prisma.SharkHotspotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharkHotspotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharkHotspotCountArgs<ExtArgs>
            result: $Utils.Optional<SharkHotspotCountAggregateOutputType> | number
          }
        }
      }
      SharkSeasonalStats: {
        payload: Prisma.$SharkSeasonalStatsPayload<ExtArgs>
        fields: Prisma.SharkSeasonalStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharkSeasonalStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharkSeasonalStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          findFirst: {
            args: Prisma.SharkSeasonalStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharkSeasonalStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          findMany: {
            args: Prisma.SharkSeasonalStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>[]
          }
          create: {
            args: Prisma.SharkSeasonalStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          createMany: {
            args: Prisma.SharkSeasonalStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharkSeasonalStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>[]
          }
          delete: {
            args: Prisma.SharkSeasonalStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          update: {
            args: Prisma.SharkSeasonalStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          deleteMany: {
            args: Prisma.SharkSeasonalStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharkSeasonalStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharkSeasonalStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>[]
          }
          upsert: {
            args: Prisma.SharkSeasonalStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharkSeasonalStatsPayload>
          }
          aggregate: {
            args: Prisma.SharkSeasonalStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharkSeasonalStats>
          }
          groupBy: {
            args: Prisma.SharkSeasonalStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharkSeasonalStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharkSeasonalStatsCountArgs<ExtArgs>
            result: $Utils.Optional<SharkSeasonalStatsCountAggregateOutputType> | number
          }
        }
      }
      MLModel: {
        payload: Prisma.$MLModelPayload<ExtArgs>
        fields: Prisma.MLModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MLModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MLModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          findFirst: {
            args: Prisma.MLModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MLModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          findMany: {
            args: Prisma.MLModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          create: {
            args: Prisma.MLModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          createMany: {
            args: Prisma.MLModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MLModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          delete: {
            args: Prisma.MLModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          update: {
            args: Prisma.MLModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          deleteMany: {
            args: Prisma.MLModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MLModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MLModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>[]
          }
          upsert: {
            args: Prisma.MLModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MLModelPayload>
          }
          aggregate: {
            args: Prisma.MLModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMLModel>
          }
          groupBy: {
            args: Prisma.MLModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<MLModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MLModelCountArgs<ExtArgs>
            result: $Utils.Optional<MLModelCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    apiKey?: ApiKeyOmit
    dataset?: DatasetOmit
    ingestionJob?: IngestionJobOmit
    observation?: ObservationOmit
    shark?: SharkOmit
    trackingData?: TrackingDataOmit
    sharkHotspot?: SharkHotspotOmit
    sharkSeasonalStats?: SharkSeasonalStatsOmit
    mLModel?: MLModelOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apiKeys: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * Count Type DatasetCountOutputType
   */

  export type DatasetCountOutputType = {
    jobs: number
    Observation: number
  }

  export type DatasetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | DatasetCountOutputTypeCountJobsArgs
    Observation?: boolean | DatasetCountOutputTypeCountObservationArgs
  }

  // Custom InputTypes
  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetCountOutputType
     */
    select?: DatasetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionJobWhereInput
  }

  /**
   * DatasetCountOutputType without action
   */
  export type DatasetCountOutputTypeCountObservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
  }


  /**
   * Count Type SharkCountOutputType
   */

  export type SharkCountOutputType = {
    trackingData: number
  }

  export type SharkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackingData?: boolean | SharkCountOutputTypeCountTrackingDataArgs
  }

  // Custom InputTypes
  /**
   * SharkCountOutputType without action
   */
  export type SharkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkCountOutputType
     */
    select?: SharkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SharkCountOutputType without action
   */
  export type SharkCountOutputTypeCountTrackingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingDataWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: number | null
    key: string | null
    userId: number | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: number | null
    key: string | null
    userId: number | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    key: number
    userId: number
    revoked: number
    createdAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ApiKeySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    revoked?: true
    createdAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    revoked?: true
    createdAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    revoked?: true
    createdAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: number
    key: string
    userId: number
    revoked: boolean
    createdAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    key?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "userId" | "revoked" | "createdAt", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      userId: number
      revoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'Int'>
    readonly key: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'Int'>
    readonly revoked: FieldRef<"ApiKey", 'Boolean'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Dataset
   */

  export type AggregateDataset = {
    _count: DatasetCountAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  export type DatasetMinAggregateOutputType = {
    id: string | null
    source: string | null
    type: string | null
    fileUrl: string | null
    ingestionDate: Date | null
    status: $Enums.DatasetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetMaxAggregateOutputType = {
    id: string | null
    source: string | null
    type: string | null
    fileUrl: string | null
    ingestionDate: Date | null
    status: $Enums.DatasetStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatasetCountAggregateOutputType = {
    id: number
    source: number
    type: number
    fileUrl: number
    ingestionDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatasetMinAggregateInputType = {
    id?: true
    source?: true
    type?: true
    fileUrl?: true
    ingestionDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetMaxAggregateInputType = {
    id?: true
    source?: true
    type?: true
    fileUrl?: true
    ingestionDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatasetCountAggregateInputType = {
    id?: true
    source?: true
    type?: true
    fileUrl?: true
    ingestionDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatasetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dataset to aggregate.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Datasets
    **/
    _count?: true | DatasetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetMaxAggregateInputType
  }

  export type GetDatasetAggregateType<T extends DatasetAggregateArgs> = {
        [P in keyof T & keyof AggregateDataset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataset[P]>
      : GetScalarType<T[P], AggregateDataset[P]>
  }




  export type DatasetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetWhereInput
    orderBy?: DatasetOrderByWithAggregationInput | DatasetOrderByWithAggregationInput[]
    by: DatasetScalarFieldEnum[] | DatasetScalarFieldEnum
    having?: DatasetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetCountAggregateInputType | true
    _min?: DatasetMinAggregateInputType
    _max?: DatasetMaxAggregateInputType
  }

  export type DatasetGroupByOutputType = {
    id: string
    source: string
    type: string
    fileUrl: string
    ingestionDate: Date
    status: $Enums.DatasetStatus
    createdAt: Date
    updatedAt: Date
    _count: DatasetCountAggregateOutputType | null
    _min: DatasetMinAggregateOutputType | null
    _max: DatasetMaxAggregateOutputType | null
  }

  type GetDatasetGroupByPayload<T extends DatasetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetGroupByOutputType[P]>
        }
      >
    >


  export type DatasetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    type?: boolean
    fileUrl?: boolean
    ingestionDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    jobs?: boolean | Dataset$jobsArgs<ExtArgs>
    Observation?: boolean | Dataset$ObservationArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    type?: boolean
    fileUrl?: boolean
    ingestionDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    type?: boolean
    fileUrl?: boolean
    ingestionDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dataset"]>

  export type DatasetSelectScalar = {
    id?: boolean
    source?: boolean
    type?: boolean
    fileUrl?: boolean
    ingestionDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatasetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "type" | "fileUrl" | "ingestionDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["dataset"]>
  export type DatasetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | Dataset$jobsArgs<ExtArgs>
    Observation?: boolean | Dataset$ObservationArgs<ExtArgs>
    _count?: boolean | DatasetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatasetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DatasetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DatasetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dataset"
    objects: {
      jobs: Prisma.$IngestionJobPayload<ExtArgs>[]
      Observation: Prisma.$ObservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      type: string
      fileUrl: string
      ingestionDate: Date
      status: $Enums.DatasetStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataset"]>
    composites: {}
  }

  type DatasetGetPayload<S extends boolean | null | undefined | DatasetDefaultArgs> = $Result.GetResult<Prisma.$DatasetPayload, S>

  type DatasetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatasetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatasetCountAggregateInputType | true
    }

  export interface DatasetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dataset'], meta: { name: 'Dataset' } }
    /**
     * Find zero or one Dataset that matches the filter.
     * @param {DatasetFindUniqueArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetFindUniqueArgs>(args: SelectSubset<T, DatasetFindUniqueArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dataset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatasetFindUniqueOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dataset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetFindFirstArgs>(args?: SelectSubset<T, DatasetFindFirstArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dataset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindFirstOrThrowArgs} args - Arguments to find a Dataset
     * @example
     * // Get one Dataset
     * const dataset = await prisma.dataset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Datasets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Datasets
     * const datasets = await prisma.dataset.findMany()
     * 
     * // Get first 10 Datasets
     * const datasets = await prisma.dataset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetWithIdOnly = await prisma.dataset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetFindManyArgs>(args?: SelectSubset<T, DatasetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dataset.
     * @param {DatasetCreateArgs} args - Arguments to create a Dataset.
     * @example
     * // Create one Dataset
     * const Dataset = await prisma.dataset.create({
     *   data: {
     *     // ... data to create a Dataset
     *   }
     * })
     * 
     */
    create<T extends DatasetCreateArgs>(args: SelectSubset<T, DatasetCreateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Datasets.
     * @param {DatasetCreateManyArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetCreateManyArgs>(args?: SelectSubset<T, DatasetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Datasets and returns the data saved in the database.
     * @param {DatasetCreateManyAndReturnArgs} args - Arguments to create many Datasets.
     * @example
     * // Create many Datasets
     * const dataset = await prisma.dataset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Datasets and only return the `id`
     * const datasetWithIdOnly = await prisma.dataset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dataset.
     * @param {DatasetDeleteArgs} args - Arguments to delete one Dataset.
     * @example
     * // Delete one Dataset
     * const Dataset = await prisma.dataset.delete({
     *   where: {
     *     // ... filter to delete one Dataset
     *   }
     * })
     * 
     */
    delete<T extends DatasetDeleteArgs>(args: SelectSubset<T, DatasetDeleteArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dataset.
     * @param {DatasetUpdateArgs} args - Arguments to update one Dataset.
     * @example
     * // Update one Dataset
     * const dataset = await prisma.dataset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetUpdateArgs>(args: SelectSubset<T, DatasetUpdateArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Datasets.
     * @param {DatasetDeleteManyArgs} args - Arguments to filter Datasets to delete.
     * @example
     * // Delete a few Datasets
     * const { count } = await prisma.dataset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetDeleteManyArgs>(args?: SelectSubset<T, DatasetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Datasets
     * const dataset = await prisma.dataset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetUpdateManyArgs>(args: SelectSubset<T, DatasetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Datasets and returns the data updated in the database.
     * @param {DatasetUpdateManyAndReturnArgs} args - Arguments to update many Datasets.
     * @example
     * // Update many Datasets
     * const dataset = await prisma.dataset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Datasets and only return the `id`
     * const datasetWithIdOnly = await prisma.dataset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatasetUpdateManyAndReturnArgs>(args: SelectSubset<T, DatasetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dataset.
     * @param {DatasetUpsertArgs} args - Arguments to update or create a Dataset.
     * @example
     * // Update or create a Dataset
     * const dataset = await prisma.dataset.upsert({
     *   create: {
     *     // ... data to create a Dataset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dataset we want to update
     *   }
     * })
     */
    upsert<T extends DatasetUpsertArgs>(args: SelectSubset<T, DatasetUpsertArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Datasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetCountArgs} args - Arguments to filter Datasets to count.
     * @example
     * // Count the number of Datasets
     * const count = await prisma.dataset.count({
     *   where: {
     *     // ... the filter for the Datasets we want to count
     *   }
     * })
    **/
    count<T extends DatasetCountArgs>(
      args?: Subset<T, DatasetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetAggregateArgs>(args: Subset<T, DatasetAggregateArgs>): Prisma.PrismaPromise<GetDatasetAggregateType<T>>

    /**
     * Group by Dataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetGroupByArgs['orderBy'] }
        : { orderBy?: DatasetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dataset model
   */
  readonly fields: DatasetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dataset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends Dataset$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Observation<T extends Dataset$ObservationArgs<ExtArgs> = {}>(args?: Subset<T, Dataset$ObservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dataset model
   */
  interface DatasetFieldRefs {
    readonly id: FieldRef<"Dataset", 'String'>
    readonly source: FieldRef<"Dataset", 'String'>
    readonly type: FieldRef<"Dataset", 'String'>
    readonly fileUrl: FieldRef<"Dataset", 'String'>
    readonly ingestionDate: FieldRef<"Dataset", 'DateTime'>
    readonly status: FieldRef<"Dataset", 'DatasetStatus'>
    readonly createdAt: FieldRef<"Dataset", 'DateTime'>
    readonly updatedAt: FieldRef<"Dataset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dataset findUnique
   */
  export type DatasetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset findUniqueOrThrow
   */
  export type DatasetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset findFirst
   */
  export type DatasetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset findFirstOrThrow
   */
  export type DatasetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Dataset to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Datasets.
     */
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset findMany
   */
  export type DatasetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter, which Datasets to fetch.
     */
    where?: DatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Datasets to fetch.
     */
    orderBy?: DatasetOrderByWithRelationInput | DatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Datasets.
     */
    cursor?: DatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Datasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Datasets.
     */
    skip?: number
    distinct?: DatasetScalarFieldEnum | DatasetScalarFieldEnum[]
  }

  /**
   * Dataset create
   */
  export type DatasetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to create a Dataset.
     */
    data: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
  }

  /**
   * Dataset createMany
   */
  export type DatasetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dataset createManyAndReturn
   */
  export type DatasetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * The data used to create many Datasets.
     */
    data: DatasetCreateManyInput | DatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dataset update
   */
  export type DatasetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The data needed to update a Dataset.
     */
    data: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
    /**
     * Choose, which Dataset to update.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset updateMany
   */
  export type DatasetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Datasets.
     */
    data: XOR<DatasetUpdateManyMutationInput, DatasetUncheckedUpdateManyInput>
    /**
     * Filter which Datasets to update
     */
    where?: DatasetWhereInput
    /**
     * Limit how many Datasets to update.
     */
    limit?: number
  }

  /**
   * Dataset updateManyAndReturn
   */
  export type DatasetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * The data used to update Datasets.
     */
    data: XOR<DatasetUpdateManyMutationInput, DatasetUncheckedUpdateManyInput>
    /**
     * Filter which Datasets to update
     */
    where?: DatasetWhereInput
    /**
     * Limit how many Datasets to update.
     */
    limit?: number
  }

  /**
   * Dataset upsert
   */
  export type DatasetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * The filter to search for the Dataset to update in case it exists.
     */
    where: DatasetWhereUniqueInput
    /**
     * In case the Dataset found by the `where` argument doesn't exist, create a new Dataset with this data.
     */
    create: XOR<DatasetCreateInput, DatasetUncheckedCreateInput>
    /**
     * In case the Dataset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetUpdateInput, DatasetUncheckedUpdateInput>
  }

  /**
   * Dataset delete
   */
  export type DatasetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
    /**
     * Filter which Dataset to delete.
     */
    where: DatasetWhereUniqueInput
  }

  /**
   * Dataset deleteMany
   */
  export type DatasetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Datasets to delete
     */
    where?: DatasetWhereInput
    /**
     * Limit how many Datasets to delete.
     */
    limit?: number
  }

  /**
   * Dataset.jobs
   */
  export type Dataset$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    where?: IngestionJobWhereInput
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    cursor?: IngestionJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * Dataset.Observation
   */
  export type Dataset$ObservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    cursor?: ObservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Dataset without action
   */
  export type DatasetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dataset
     */
    select?: DatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dataset
     */
    omit?: DatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetInclude<ExtArgs> | null
  }


  /**
   * Model IngestionJob
   */

  export type AggregateIngestionJob = {
    _count: IngestionJobCountAggregateOutputType | null
    _min: IngestionJobMinAggregateOutputType | null
    _max: IngestionJobMaxAggregateOutputType | null
  }

  export type IngestionJobMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    status: $Enums.JobStatus | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
  }

  export type IngestionJobMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    status: $Enums.JobStatus | null
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
  }

  export type IngestionJobCountAggregateOutputType = {
    id: number
    datasetId: number
    status: number
    startedAt: number
    completedAt: number
    error: number
    _all: number
  }


  export type IngestionJobMinAggregateInputType = {
    id?: true
    datasetId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    error?: true
  }

  export type IngestionJobMaxAggregateInputType = {
    id?: true
    datasetId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    error?: true
  }

  export type IngestionJobCountAggregateInputType = {
    id?: true
    datasetId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    error?: true
    _all?: true
  }

  export type IngestionJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionJob to aggregate.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngestionJobs
    **/
    _count?: true | IngestionJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngestionJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngestionJobMaxAggregateInputType
  }

  export type GetIngestionJobAggregateType<T extends IngestionJobAggregateArgs> = {
        [P in keyof T & keyof AggregateIngestionJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngestionJob[P]>
      : GetScalarType<T[P], AggregateIngestionJob[P]>
  }




  export type IngestionJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngestionJobWhereInput
    orderBy?: IngestionJobOrderByWithAggregationInput | IngestionJobOrderByWithAggregationInput[]
    by: IngestionJobScalarFieldEnum[] | IngestionJobScalarFieldEnum
    having?: IngestionJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngestionJobCountAggregateInputType | true
    _min?: IngestionJobMinAggregateInputType
    _max?: IngestionJobMaxAggregateInputType
  }

  export type IngestionJobGroupByOutputType = {
    id: string
    datasetId: string
    status: $Enums.JobStatus
    startedAt: Date | null
    completedAt: Date | null
    error: string | null
    _count: IngestionJobCountAggregateOutputType | null
    _min: IngestionJobMinAggregateOutputType | null
    _max: IngestionJobMaxAggregateOutputType | null
  }

  type GetIngestionJobGroupByPayload<T extends IngestionJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngestionJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngestionJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngestionJobGroupByOutputType[P]>
            : GetScalarType<T[P], IngestionJobGroupByOutputType[P]>
        }
      >
    >


  export type IngestionJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionJob"]>

  export type IngestionJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionJob"]>

  export type IngestionJobSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingestionJob"]>

  export type IngestionJobSelectScalar = {
    id?: boolean
    datasetId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    error?: boolean
  }

  export type IngestionJobOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datasetId" | "status" | "startedAt" | "completedAt" | "error", ExtArgs["result"]["ingestionJob"]>
  export type IngestionJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type IngestionJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type IngestionJobIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $IngestionJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngestionJob"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      status: $Enums.JobStatus
      startedAt: Date | null
      completedAt: Date | null
      error: string | null
    }, ExtArgs["result"]["ingestionJob"]>
    composites: {}
  }

  type IngestionJobGetPayload<S extends boolean | null | undefined | IngestionJobDefaultArgs> = $Result.GetResult<Prisma.$IngestionJobPayload, S>

  type IngestionJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngestionJobFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IngestionJobCountAggregateInputType | true
    }

  export interface IngestionJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngestionJob'], meta: { name: 'IngestionJob' } }
    /**
     * Find zero or one IngestionJob that matches the filter.
     * @param {IngestionJobFindUniqueArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngestionJobFindUniqueArgs>(args: SelectSubset<T, IngestionJobFindUniqueArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IngestionJob that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngestionJobFindUniqueOrThrowArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngestionJobFindUniqueOrThrowArgs>(args: SelectSubset<T, IngestionJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestionJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindFirstArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngestionJobFindFirstArgs>(args?: SelectSubset<T, IngestionJobFindFirstArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IngestionJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindFirstOrThrowArgs} args - Arguments to find a IngestionJob
     * @example
     * // Get one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngestionJobFindFirstOrThrowArgs>(args?: SelectSubset<T, IngestionJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IngestionJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngestionJobs
     * const ingestionJobs = await prisma.ingestionJob.findMany()
     * 
     * // Get first 10 IngestionJobs
     * const ingestionJobs = await prisma.ingestionJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingestionJobWithIdOnly = await prisma.ingestionJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngestionJobFindManyArgs>(args?: SelectSubset<T, IngestionJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IngestionJob.
     * @param {IngestionJobCreateArgs} args - Arguments to create a IngestionJob.
     * @example
     * // Create one IngestionJob
     * const IngestionJob = await prisma.ingestionJob.create({
     *   data: {
     *     // ... data to create a IngestionJob
     *   }
     * })
     * 
     */
    create<T extends IngestionJobCreateArgs>(args: SelectSubset<T, IngestionJobCreateArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IngestionJobs.
     * @param {IngestionJobCreateManyArgs} args - Arguments to create many IngestionJobs.
     * @example
     * // Create many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngestionJobCreateManyArgs>(args?: SelectSubset<T, IngestionJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IngestionJobs and returns the data saved in the database.
     * @param {IngestionJobCreateManyAndReturnArgs} args - Arguments to create many IngestionJobs.
     * @example
     * // Create many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IngestionJobs and only return the `id`
     * const ingestionJobWithIdOnly = await prisma.ingestionJob.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngestionJobCreateManyAndReturnArgs>(args?: SelectSubset<T, IngestionJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IngestionJob.
     * @param {IngestionJobDeleteArgs} args - Arguments to delete one IngestionJob.
     * @example
     * // Delete one IngestionJob
     * const IngestionJob = await prisma.ingestionJob.delete({
     *   where: {
     *     // ... filter to delete one IngestionJob
     *   }
     * })
     * 
     */
    delete<T extends IngestionJobDeleteArgs>(args: SelectSubset<T, IngestionJobDeleteArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IngestionJob.
     * @param {IngestionJobUpdateArgs} args - Arguments to update one IngestionJob.
     * @example
     * // Update one IngestionJob
     * const ingestionJob = await prisma.ingestionJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngestionJobUpdateArgs>(args: SelectSubset<T, IngestionJobUpdateArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IngestionJobs.
     * @param {IngestionJobDeleteManyArgs} args - Arguments to filter IngestionJobs to delete.
     * @example
     * // Delete a few IngestionJobs
     * const { count } = await prisma.ingestionJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngestionJobDeleteManyArgs>(args?: SelectSubset<T, IngestionJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestionJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngestionJobUpdateManyArgs>(args: SelectSubset<T, IngestionJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngestionJobs and returns the data updated in the database.
     * @param {IngestionJobUpdateManyAndReturnArgs} args - Arguments to update many IngestionJobs.
     * @example
     * // Update many IngestionJobs
     * const ingestionJob = await prisma.ingestionJob.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IngestionJobs and only return the `id`
     * const ingestionJobWithIdOnly = await prisma.ingestionJob.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IngestionJobUpdateManyAndReturnArgs>(args: SelectSubset<T, IngestionJobUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IngestionJob.
     * @param {IngestionJobUpsertArgs} args - Arguments to update or create a IngestionJob.
     * @example
     * // Update or create a IngestionJob
     * const ingestionJob = await prisma.ingestionJob.upsert({
     *   create: {
     *     // ... data to create a IngestionJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngestionJob we want to update
     *   }
     * })
     */
    upsert<T extends IngestionJobUpsertArgs>(args: SelectSubset<T, IngestionJobUpsertArgs<ExtArgs>>): Prisma__IngestionJobClient<$Result.GetResult<Prisma.$IngestionJobPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IngestionJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobCountArgs} args - Arguments to filter IngestionJobs to count.
     * @example
     * // Count the number of IngestionJobs
     * const count = await prisma.ingestionJob.count({
     *   where: {
     *     // ... the filter for the IngestionJobs we want to count
     *   }
     * })
    **/
    count<T extends IngestionJobCountArgs>(
      args?: Subset<T, IngestionJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngestionJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngestionJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngestionJobAggregateArgs>(args: Subset<T, IngestionJobAggregateArgs>): Prisma.PrismaPromise<GetIngestionJobAggregateType<T>>

    /**
     * Group by IngestionJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngestionJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngestionJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngestionJobGroupByArgs['orderBy'] }
        : { orderBy?: IngestionJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngestionJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngestionJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngestionJob model
   */
  readonly fields: IngestionJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngestionJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngestionJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IngestionJob model
   */
  interface IngestionJobFieldRefs {
    readonly id: FieldRef<"IngestionJob", 'String'>
    readonly datasetId: FieldRef<"IngestionJob", 'String'>
    readonly status: FieldRef<"IngestionJob", 'JobStatus'>
    readonly startedAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly completedAt: FieldRef<"IngestionJob", 'DateTime'>
    readonly error: FieldRef<"IngestionJob", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IngestionJob findUnique
   */
  export type IngestionJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob findUniqueOrThrow
   */
  export type IngestionJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob findFirst
   */
  export type IngestionJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionJobs.
     */
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob findFirstOrThrow
   */
  export type IngestionJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJob to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngestionJobs.
     */
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob findMany
   */
  export type IngestionJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter, which IngestionJobs to fetch.
     */
    where?: IngestionJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngestionJobs to fetch.
     */
    orderBy?: IngestionJobOrderByWithRelationInput | IngestionJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngestionJobs.
     */
    cursor?: IngestionJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngestionJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngestionJobs.
     */
    skip?: number
    distinct?: IngestionJobScalarFieldEnum | IngestionJobScalarFieldEnum[]
  }

  /**
   * IngestionJob create
   */
  export type IngestionJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The data needed to create a IngestionJob.
     */
    data: XOR<IngestionJobCreateInput, IngestionJobUncheckedCreateInput>
  }

  /**
   * IngestionJob createMany
   */
  export type IngestionJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngestionJobs.
     */
    data: IngestionJobCreateManyInput | IngestionJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IngestionJob createManyAndReturn
   */
  export type IngestionJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * The data used to create many IngestionJobs.
     */
    data: IngestionJobCreateManyInput | IngestionJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestionJob update
   */
  export type IngestionJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The data needed to update a IngestionJob.
     */
    data: XOR<IngestionJobUpdateInput, IngestionJobUncheckedUpdateInput>
    /**
     * Choose, which IngestionJob to update.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob updateMany
   */
  export type IngestionJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngestionJobs.
     */
    data: XOR<IngestionJobUpdateManyMutationInput, IngestionJobUncheckedUpdateManyInput>
    /**
     * Filter which IngestionJobs to update
     */
    where?: IngestionJobWhereInput
    /**
     * Limit how many IngestionJobs to update.
     */
    limit?: number
  }

  /**
   * IngestionJob updateManyAndReturn
   */
  export type IngestionJobUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * The data used to update IngestionJobs.
     */
    data: XOR<IngestionJobUpdateManyMutationInput, IngestionJobUncheckedUpdateManyInput>
    /**
     * Filter which IngestionJobs to update
     */
    where?: IngestionJobWhereInput
    /**
     * Limit how many IngestionJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IngestionJob upsert
   */
  export type IngestionJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * The filter to search for the IngestionJob to update in case it exists.
     */
    where: IngestionJobWhereUniqueInput
    /**
     * In case the IngestionJob found by the `where` argument doesn't exist, create a new IngestionJob with this data.
     */
    create: XOR<IngestionJobCreateInput, IngestionJobUncheckedCreateInput>
    /**
     * In case the IngestionJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngestionJobUpdateInput, IngestionJobUncheckedUpdateInput>
  }

  /**
   * IngestionJob delete
   */
  export type IngestionJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
    /**
     * Filter which IngestionJob to delete.
     */
    where: IngestionJobWhereUniqueInput
  }

  /**
   * IngestionJob deleteMany
   */
  export type IngestionJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngestionJobs to delete
     */
    where?: IngestionJobWhereInput
    /**
     * Limit how many IngestionJobs to delete.
     */
    limit?: number
  }

  /**
   * IngestionJob without action
   */
  export type IngestionJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngestionJob
     */
    select?: IngestionJobSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IngestionJob
     */
    omit?: IngestionJobOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngestionJobInclude<ExtArgs> | null
  }


  /**
   * Model Observation
   */

  export type AggregateObservation = {
    _count: ObservationCountAggregateOutputType | null
    _avg: ObservationAvgAggregateOutputType | null
    _sum: ObservationSumAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  export type ObservationAvgAggregateOutputType = {
    lat: number | null
    lon: number | null
    chlorophyll: number | null
    sst: number | null
    eddyStrength: number | null
  }

  export type ObservationSumAggregateOutputType = {
    lat: number | null
    lon: number | null
    chlorophyll: number | null
    sst: number | null
    eddyStrength: number | null
  }

  export type ObservationMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    lat: number | null
    lon: number | null
    chlorophyll: number | null
    sst: number | null
    eddyStrength: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ObservationMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    lat: number | null
    lon: number | null
    chlorophyll: number | null
    sst: number | null
    eddyStrength: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ObservationCountAggregateOutputType = {
    id: number
    datasetId: number
    lat: number
    lon: number
    chlorophyll: number
    sst: number
    eddyStrength: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type ObservationAvgAggregateInputType = {
    lat?: true
    lon?: true
    chlorophyll?: true
    sst?: true
    eddyStrength?: true
  }

  export type ObservationSumAggregateInputType = {
    lat?: true
    lon?: true
    chlorophyll?: true
    sst?: true
    eddyStrength?: true
  }

  export type ObservationMinAggregateInputType = {
    id?: true
    datasetId?: true
    lat?: true
    lon?: true
    chlorophyll?: true
    sst?: true
    eddyStrength?: true
    timestamp?: true
    createdAt?: true
  }

  export type ObservationMaxAggregateInputType = {
    id?: true
    datasetId?: true
    lat?: true
    lon?: true
    chlorophyll?: true
    sst?: true
    eddyStrength?: true
    timestamp?: true
    createdAt?: true
  }

  export type ObservationCountAggregateInputType = {
    id?: true
    datasetId?: true
    lat?: true
    lon?: true
    chlorophyll?: true
    sst?: true
    eddyStrength?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type ObservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observation to aggregate.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Observations
    **/
    _count?: true | ObservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationMaxAggregateInputType
  }

  export type GetObservationAggregateType<T extends ObservationAggregateArgs> = {
        [P in keyof T & keyof AggregateObservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservation[P]>
      : GetScalarType<T[P], AggregateObservation[P]>
  }




  export type ObservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithAggregationInput | ObservationOrderByWithAggregationInput[]
    by: ObservationScalarFieldEnum[] | ObservationScalarFieldEnum
    having?: ObservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationCountAggregateInputType | true
    _avg?: ObservationAvgAggregateInputType
    _sum?: ObservationSumAggregateInputType
    _min?: ObservationMinAggregateInputType
    _max?: ObservationMaxAggregateInputType
  }

  export type ObservationGroupByOutputType = {
    id: string
    datasetId: string
    lat: number
    lon: number
    chlorophyll: number | null
    sst: number | null
    eddyStrength: number | null
    timestamp: Date
    createdAt: Date
    _count: ObservationCountAggregateOutputType | null
    _avg: ObservationAvgAggregateOutputType | null
    _sum: ObservationSumAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  type GetObservationGroupByPayload<T extends ObservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationGroupByOutputType[P]>
        }
      >
    >


  export type ObservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    lat?: boolean
    lon?: boolean
    chlorophyll?: boolean
    sst?: boolean
    eddyStrength?: boolean
    timestamp?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    lat?: boolean
    lon?: boolean
    chlorophyll?: boolean
    sst?: boolean
    eddyStrength?: boolean
    timestamp?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    lat?: boolean
    lon?: boolean
    chlorophyll?: boolean
    sst?: boolean
    eddyStrength?: boolean
    timestamp?: boolean
    createdAt?: boolean
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>

  export type ObservationSelectScalar = {
    id?: boolean
    datasetId?: boolean
    lat?: boolean
    lon?: boolean
    chlorophyll?: boolean
    sst?: boolean
    eddyStrength?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type ObservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datasetId" | "lat" | "lon" | "chlorophyll" | "sst" | "eddyStrength" | "timestamp" | "createdAt", ExtArgs["result"]["observation"]>
  export type ObservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type ObservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }
  export type ObservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetDefaultArgs<ExtArgs>
  }

  export type $ObservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Observation"
    objects: {
      dataset: Prisma.$DatasetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string
      lat: number
      lon: number
      chlorophyll: number | null
      sst: number | null
      eddyStrength: number | null
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["observation"]>
    composites: {}
  }

  type ObservationGetPayload<S extends boolean | null | undefined | ObservationDefaultArgs> = $Result.GetResult<Prisma.$ObservationPayload, S>

  type ObservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObservationCountAggregateInputType | true
    }

  export interface ObservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Observation'], meta: { name: 'Observation' } }
    /**
     * Find zero or one Observation that matches the filter.
     * @param {ObservationFindUniqueArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationFindUniqueArgs>(args: SelectSubset<T, ObservationFindUniqueArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Observation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObservationFindUniqueOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Observation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationFindFirstArgs>(args?: SelectSubset<T, ObservationFindFirstArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Observation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Observations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Observations
     * const observations = await prisma.observation.findMany()
     * 
     * // Get first 10 Observations
     * const observations = await prisma.observation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationWithIdOnly = await prisma.observation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationFindManyArgs>(args?: SelectSubset<T, ObservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Observation.
     * @param {ObservationCreateArgs} args - Arguments to create a Observation.
     * @example
     * // Create one Observation
     * const Observation = await prisma.observation.create({
     *   data: {
     *     // ... data to create a Observation
     *   }
     * })
     * 
     */
    create<T extends ObservationCreateArgs>(args: SelectSubset<T, ObservationCreateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Observations.
     * @param {ObservationCreateManyArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationCreateManyArgs>(args?: SelectSubset<T, ObservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Observations and returns the data saved in the database.
     * @param {ObservationCreateManyAndReturnArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Observations and only return the `id`
     * const observationWithIdOnly = await prisma.observation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Observation.
     * @param {ObservationDeleteArgs} args - Arguments to delete one Observation.
     * @example
     * // Delete one Observation
     * const Observation = await prisma.observation.delete({
     *   where: {
     *     // ... filter to delete one Observation
     *   }
     * })
     * 
     */
    delete<T extends ObservationDeleteArgs>(args: SelectSubset<T, ObservationDeleteArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Observation.
     * @param {ObservationUpdateArgs} args - Arguments to update one Observation.
     * @example
     * // Update one Observation
     * const observation = await prisma.observation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationUpdateArgs>(args: SelectSubset<T, ObservationUpdateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Observations.
     * @param {ObservationDeleteManyArgs} args - Arguments to filter Observations to delete.
     * @example
     * // Delete a few Observations
     * const { count } = await prisma.observation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationDeleteManyArgs>(args?: SelectSubset<T, ObservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationUpdateManyArgs>(args: SelectSubset<T, ObservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations and returns the data updated in the database.
     * @param {ObservationUpdateManyAndReturnArgs} args - Arguments to update many Observations.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Observations and only return the `id`
     * const observationWithIdOnly = await prisma.observation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ObservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Observation.
     * @param {ObservationUpsertArgs} args - Arguments to update or create a Observation.
     * @example
     * // Update or create a Observation
     * const observation = await prisma.observation.upsert({
     *   create: {
     *     // ... data to create a Observation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Observation we want to update
     *   }
     * })
     */
    upsert<T extends ObservationUpsertArgs>(args: SelectSubset<T, ObservationUpsertArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationCountArgs} args - Arguments to filter Observations to count.
     * @example
     * // Count the number of Observations
     * const count = await prisma.observation.count({
     *   where: {
     *     // ... the filter for the Observations we want to count
     *   }
     * })
    **/
    count<T extends ObservationCountArgs>(
      args?: Subset<T, ObservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationAggregateArgs>(args: Subset<T, ObservationAggregateArgs>): Prisma.PrismaPromise<GetObservationAggregateType<T>>

    /**
     * Group by Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationGroupByArgs['orderBy'] }
        : { orderBy?: ObservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Observation model
   */
  readonly fields: ObservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Observation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatasetDefaultArgs<ExtArgs>>): Prisma__DatasetClient<$Result.GetResult<Prisma.$DatasetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Observation model
   */
  interface ObservationFieldRefs {
    readonly id: FieldRef<"Observation", 'String'>
    readonly datasetId: FieldRef<"Observation", 'String'>
    readonly lat: FieldRef<"Observation", 'Float'>
    readonly lon: FieldRef<"Observation", 'Float'>
    readonly chlorophyll: FieldRef<"Observation", 'Float'>
    readonly sst: FieldRef<"Observation", 'Float'>
    readonly eddyStrength: FieldRef<"Observation", 'Float'>
    readonly timestamp: FieldRef<"Observation", 'DateTime'>
    readonly createdAt: FieldRef<"Observation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Observation findUnique
   */
  export type ObservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findUniqueOrThrow
   */
  export type ObservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findFirst
   */
  export type ObservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findFirstOrThrow
   */
  export type ObservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findMany
   */
  export type ObservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observations to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation create
   */
  export type ObservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Observation.
     */
    data: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
  }

  /**
   * Observation createMany
   */
  export type ObservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Observation createManyAndReturn
   */
  export type ObservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Observation update
   */
  export type ObservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Observation.
     */
    data: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
    /**
     * Choose, which Observation to update.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation updateMany
   */
  export type ObservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to update.
     */
    limit?: number
  }

  /**
   * Observation updateManyAndReturn
   */
  export type ObservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Observation upsert
   */
  export type ObservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Observation to update in case it exists.
     */
    where: ObservationWhereUniqueInput
    /**
     * In case the Observation found by the `where` argument doesn't exist, create a new Observation with this data.
     */
    create: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
    /**
     * In case the Observation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
  }

  /**
   * Observation delete
   */
  export type ObservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter which Observation to delete.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation deleteMany
   */
  export type ObservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observations to delete
     */
    where?: ObservationWhereInput
    /**
     * Limit how many Observations to delete.
     */
    limit?: number
  }

  /**
   * Observation without action
   */
  export type ObservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Observation
     */
    omit?: ObservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
  }


  /**
   * Model Shark
   */

  export type AggregateShark = {
    _count: SharkCountAggregateOutputType | null
    _avg: SharkAvgAggregateOutputType | null
    _sum: SharkSumAggregateOutputType | null
    _min: SharkMinAggregateOutputType | null
    _max: SharkMaxAggregateOutputType | null
  }

  export type SharkAvgAggregateOutputType = {
    lengthCm: number | null
    weightKg: number | null
  }

  export type SharkSumAggregateOutputType = {
    lengthCm: number | null
    weightKg: number | null
  }

  export type SharkMinAggregateOutputType = {
    id: string | null
    tagId: string | null
    species: string | null
    sex: string | null
    lengthCm: number | null
    weightKg: number | null
    releaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SharkMaxAggregateOutputType = {
    id: string | null
    tagId: string | null
    species: string | null
    sex: string | null
    lengthCm: number | null
    weightKg: number | null
    releaseDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SharkCountAggregateOutputType = {
    id: number
    tagId: number
    species: number
    sex: number
    lengthCm: number
    weightKg: number
    releaseDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SharkAvgAggregateInputType = {
    lengthCm?: true
    weightKg?: true
  }

  export type SharkSumAggregateInputType = {
    lengthCm?: true
    weightKg?: true
  }

  export type SharkMinAggregateInputType = {
    id?: true
    tagId?: true
    species?: true
    sex?: true
    lengthCm?: true
    weightKg?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SharkMaxAggregateInputType = {
    id?: true
    tagId?: true
    species?: true
    sex?: true
    lengthCm?: true
    weightKg?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SharkCountAggregateInputType = {
    id?: true
    tagId?: true
    species?: true
    sex?: true
    lengthCm?: true
    weightKg?: true
    releaseDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SharkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shark to aggregate.
     */
    where?: SharkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sharks to fetch.
     */
    orderBy?: SharkOrderByWithRelationInput | SharkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sharks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sharks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sharks
    **/
    _count?: true | SharkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharkMaxAggregateInputType
  }

  export type GetSharkAggregateType<T extends SharkAggregateArgs> = {
        [P in keyof T & keyof AggregateShark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShark[P]>
      : GetScalarType<T[P], AggregateShark[P]>
  }




  export type SharkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharkWhereInput
    orderBy?: SharkOrderByWithAggregationInput | SharkOrderByWithAggregationInput[]
    by: SharkScalarFieldEnum[] | SharkScalarFieldEnum
    having?: SharkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharkCountAggregateInputType | true
    _avg?: SharkAvgAggregateInputType
    _sum?: SharkSumAggregateInputType
    _min?: SharkMinAggregateInputType
    _max?: SharkMaxAggregateInputType
  }

  export type SharkGroupByOutputType = {
    id: string
    tagId: string
    species: string | null
    sex: string | null
    lengthCm: number | null
    weightKg: number | null
    releaseDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SharkCountAggregateOutputType | null
    _avg: SharkAvgAggregateOutputType | null
    _sum: SharkSumAggregateOutputType | null
    _min: SharkMinAggregateOutputType | null
    _max: SharkMaxAggregateOutputType | null
  }

  type GetSharkGroupByPayload<T extends SharkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharkGroupByOutputType[P]>
            : GetScalarType<T[P], SharkGroupByOutputType[P]>
        }
      >
    >


  export type SharkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    species?: boolean
    sex?: boolean
    lengthCm?: boolean
    weightKg?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trackingData?: boolean | Shark$trackingDataArgs<ExtArgs>
    _count?: boolean | SharkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shark"]>

  export type SharkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    species?: boolean
    sex?: boolean
    lengthCm?: boolean
    weightKg?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shark"]>

  export type SharkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    species?: boolean
    sex?: boolean
    lengthCm?: boolean
    weightKg?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["shark"]>

  export type SharkSelectScalar = {
    id?: boolean
    tagId?: boolean
    species?: boolean
    sex?: boolean
    lengthCm?: boolean
    weightKg?: boolean
    releaseDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SharkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagId" | "species" | "sex" | "lengthCm" | "weightKg" | "releaseDate" | "createdAt" | "updatedAt", ExtArgs["result"]["shark"]>
  export type SharkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackingData?: boolean | Shark$trackingDataArgs<ExtArgs>
    _count?: boolean | SharkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SharkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SharkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SharkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shark"
    objects: {
      trackingData: Prisma.$TrackingDataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagId: string
      species: string | null
      sex: string | null
      lengthCm: number | null
      weightKg: number | null
      releaseDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shark"]>
    composites: {}
  }

  type SharkGetPayload<S extends boolean | null | undefined | SharkDefaultArgs> = $Result.GetResult<Prisma.$SharkPayload, S>

  type SharkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharkCountAggregateInputType | true
    }

  export interface SharkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shark'], meta: { name: 'Shark' } }
    /**
     * Find zero or one Shark that matches the filter.
     * @param {SharkFindUniqueArgs} args - Arguments to find a Shark
     * @example
     * // Get one Shark
     * const shark = await prisma.shark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharkFindUniqueArgs>(args: SelectSubset<T, SharkFindUniqueArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharkFindUniqueOrThrowArgs} args - Arguments to find a Shark
     * @example
     * // Get one Shark
     * const shark = await prisma.shark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharkFindUniqueOrThrowArgs>(args: SelectSubset<T, SharkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkFindFirstArgs} args - Arguments to find a Shark
     * @example
     * // Get one Shark
     * const shark = await prisma.shark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharkFindFirstArgs>(args?: SelectSubset<T, SharkFindFirstArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkFindFirstOrThrowArgs} args - Arguments to find a Shark
     * @example
     * // Get one Shark
     * const shark = await prisma.shark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharkFindFirstOrThrowArgs>(args?: SelectSubset<T, SharkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sharks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sharks
     * const sharks = await prisma.shark.findMany()
     * 
     * // Get first 10 Sharks
     * const sharks = await prisma.shark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharkWithIdOnly = await prisma.shark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharkFindManyArgs>(args?: SelectSubset<T, SharkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shark.
     * @param {SharkCreateArgs} args - Arguments to create a Shark.
     * @example
     * // Create one Shark
     * const Shark = await prisma.shark.create({
     *   data: {
     *     // ... data to create a Shark
     *   }
     * })
     * 
     */
    create<T extends SharkCreateArgs>(args: SelectSubset<T, SharkCreateArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sharks.
     * @param {SharkCreateManyArgs} args - Arguments to create many Sharks.
     * @example
     * // Create many Sharks
     * const shark = await prisma.shark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharkCreateManyArgs>(args?: SelectSubset<T, SharkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sharks and returns the data saved in the database.
     * @param {SharkCreateManyAndReturnArgs} args - Arguments to create many Sharks.
     * @example
     * // Create many Sharks
     * const shark = await prisma.shark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sharks and only return the `id`
     * const sharkWithIdOnly = await prisma.shark.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharkCreateManyAndReturnArgs>(args?: SelectSubset<T, SharkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shark.
     * @param {SharkDeleteArgs} args - Arguments to delete one Shark.
     * @example
     * // Delete one Shark
     * const Shark = await prisma.shark.delete({
     *   where: {
     *     // ... filter to delete one Shark
     *   }
     * })
     * 
     */
    delete<T extends SharkDeleteArgs>(args: SelectSubset<T, SharkDeleteArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shark.
     * @param {SharkUpdateArgs} args - Arguments to update one Shark.
     * @example
     * // Update one Shark
     * const shark = await prisma.shark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharkUpdateArgs>(args: SelectSubset<T, SharkUpdateArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sharks.
     * @param {SharkDeleteManyArgs} args - Arguments to filter Sharks to delete.
     * @example
     * // Delete a few Sharks
     * const { count } = await prisma.shark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharkDeleteManyArgs>(args?: SelectSubset<T, SharkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sharks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sharks
     * const shark = await prisma.shark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharkUpdateManyArgs>(args: SelectSubset<T, SharkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sharks and returns the data updated in the database.
     * @param {SharkUpdateManyAndReturnArgs} args - Arguments to update many Sharks.
     * @example
     * // Update many Sharks
     * const shark = await prisma.shark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sharks and only return the `id`
     * const sharkWithIdOnly = await prisma.shark.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharkUpdateManyAndReturnArgs>(args: SelectSubset<T, SharkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shark.
     * @param {SharkUpsertArgs} args - Arguments to update or create a Shark.
     * @example
     * // Update or create a Shark
     * const shark = await prisma.shark.upsert({
     *   create: {
     *     // ... data to create a Shark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shark we want to update
     *   }
     * })
     */
    upsert<T extends SharkUpsertArgs>(args: SelectSubset<T, SharkUpsertArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sharks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkCountArgs} args - Arguments to filter Sharks to count.
     * @example
     * // Count the number of Sharks
     * const count = await prisma.shark.count({
     *   where: {
     *     // ... the filter for the Sharks we want to count
     *   }
     * })
    **/
    count<T extends SharkCountArgs>(
      args?: Subset<T, SharkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharkAggregateArgs>(args: Subset<T, SharkAggregateArgs>): Prisma.PrismaPromise<GetSharkAggregateType<T>>

    /**
     * Group by Shark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharkGroupByArgs['orderBy'] }
        : { orderBy?: SharkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shark model
   */
  readonly fields: SharkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trackingData<T extends Shark$trackingDataArgs<ExtArgs> = {}>(args?: Subset<T, Shark$trackingDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shark model
   */
  interface SharkFieldRefs {
    readonly id: FieldRef<"Shark", 'String'>
    readonly tagId: FieldRef<"Shark", 'String'>
    readonly species: FieldRef<"Shark", 'String'>
    readonly sex: FieldRef<"Shark", 'String'>
    readonly lengthCm: FieldRef<"Shark", 'Float'>
    readonly weightKg: FieldRef<"Shark", 'Float'>
    readonly releaseDate: FieldRef<"Shark", 'DateTime'>
    readonly createdAt: FieldRef<"Shark", 'DateTime'>
    readonly updatedAt: FieldRef<"Shark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shark findUnique
   */
  export type SharkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter, which Shark to fetch.
     */
    where: SharkWhereUniqueInput
  }

  /**
   * Shark findUniqueOrThrow
   */
  export type SharkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter, which Shark to fetch.
     */
    where: SharkWhereUniqueInput
  }

  /**
   * Shark findFirst
   */
  export type SharkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter, which Shark to fetch.
     */
    where?: SharkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sharks to fetch.
     */
    orderBy?: SharkOrderByWithRelationInput | SharkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sharks.
     */
    cursor?: SharkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sharks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sharks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sharks.
     */
    distinct?: SharkScalarFieldEnum | SharkScalarFieldEnum[]
  }

  /**
   * Shark findFirstOrThrow
   */
  export type SharkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter, which Shark to fetch.
     */
    where?: SharkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sharks to fetch.
     */
    orderBy?: SharkOrderByWithRelationInput | SharkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sharks.
     */
    cursor?: SharkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sharks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sharks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sharks.
     */
    distinct?: SharkScalarFieldEnum | SharkScalarFieldEnum[]
  }

  /**
   * Shark findMany
   */
  export type SharkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter, which Sharks to fetch.
     */
    where?: SharkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sharks to fetch.
     */
    orderBy?: SharkOrderByWithRelationInput | SharkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sharks.
     */
    cursor?: SharkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sharks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sharks.
     */
    skip?: number
    distinct?: SharkScalarFieldEnum | SharkScalarFieldEnum[]
  }

  /**
   * Shark create
   */
  export type SharkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * The data needed to create a Shark.
     */
    data: XOR<SharkCreateInput, SharkUncheckedCreateInput>
  }

  /**
   * Shark createMany
   */
  export type SharkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sharks.
     */
    data: SharkCreateManyInput | SharkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shark createManyAndReturn
   */
  export type SharkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * The data used to create many Sharks.
     */
    data: SharkCreateManyInput | SharkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shark update
   */
  export type SharkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * The data needed to update a Shark.
     */
    data: XOR<SharkUpdateInput, SharkUncheckedUpdateInput>
    /**
     * Choose, which Shark to update.
     */
    where: SharkWhereUniqueInput
  }

  /**
   * Shark updateMany
   */
  export type SharkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sharks.
     */
    data: XOR<SharkUpdateManyMutationInput, SharkUncheckedUpdateManyInput>
    /**
     * Filter which Sharks to update
     */
    where?: SharkWhereInput
    /**
     * Limit how many Sharks to update.
     */
    limit?: number
  }

  /**
   * Shark updateManyAndReturn
   */
  export type SharkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * The data used to update Sharks.
     */
    data: XOR<SharkUpdateManyMutationInput, SharkUncheckedUpdateManyInput>
    /**
     * Filter which Sharks to update
     */
    where?: SharkWhereInput
    /**
     * Limit how many Sharks to update.
     */
    limit?: number
  }

  /**
   * Shark upsert
   */
  export type SharkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * The filter to search for the Shark to update in case it exists.
     */
    where: SharkWhereUniqueInput
    /**
     * In case the Shark found by the `where` argument doesn't exist, create a new Shark with this data.
     */
    create: XOR<SharkCreateInput, SharkUncheckedCreateInput>
    /**
     * In case the Shark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharkUpdateInput, SharkUncheckedUpdateInput>
  }

  /**
   * Shark delete
   */
  export type SharkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
    /**
     * Filter which Shark to delete.
     */
    where: SharkWhereUniqueInput
  }

  /**
   * Shark deleteMany
   */
  export type SharkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sharks to delete
     */
    where?: SharkWhereInput
    /**
     * Limit how many Sharks to delete.
     */
    limit?: number
  }

  /**
   * Shark.trackingData
   */
  export type Shark$trackingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    where?: TrackingDataWhereInput
    orderBy?: TrackingDataOrderByWithRelationInput | TrackingDataOrderByWithRelationInput[]
    cursor?: TrackingDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackingDataScalarFieldEnum | TrackingDataScalarFieldEnum[]
  }

  /**
   * Shark without action
   */
  export type SharkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shark
     */
    select?: SharkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shark
     */
    omit?: SharkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharkInclude<ExtArgs> | null
  }


  /**
   * Model TrackingData
   */

  export type AggregateTrackingData = {
    _count: TrackingDataCountAggregateOutputType | null
    _avg: TrackingDataAvgAggregateOutputType | null
    _sum: TrackingDataSumAggregateOutputType | null
    _min: TrackingDataMinAggregateOutputType | null
    _max: TrackingDataMaxAggregateOutputType | null
  }

  export type TrackingDataAvgAggregateOutputType = {
    lat: number | null
    lon: number | null
    depth: number | null
    temperature: number | null
    chlorophyll: number | null
    sst: number | null
  }

  export type TrackingDataSumAggregateOutputType = {
    lat: number | null
    lon: number | null
    depth: number | null
    temperature: number | null
    chlorophyll: number | null
    sst: number | null
  }

  export type TrackingDataMinAggregateOutputType = {
    id: string | null
    sharkId: string | null
    lat: number | null
    lon: number | null
    timestamp: Date | null
    depth: number | null
    temperature: number | null
    eddyId: string | null
    chlorophyll: number | null
    sst: number | null
    createdAt: Date | null
  }

  export type TrackingDataMaxAggregateOutputType = {
    id: string | null
    sharkId: string | null
    lat: number | null
    lon: number | null
    timestamp: Date | null
    depth: number | null
    temperature: number | null
    eddyId: string | null
    chlorophyll: number | null
    sst: number | null
    createdAt: Date | null
  }

  export type TrackingDataCountAggregateOutputType = {
    id: number
    sharkId: number
    lat: number
    lon: number
    timestamp: number
    depth: number
    temperature: number
    eddyId: number
    chlorophyll: number
    sst: number
    createdAt: number
    _all: number
  }


  export type TrackingDataAvgAggregateInputType = {
    lat?: true
    lon?: true
    depth?: true
    temperature?: true
    chlorophyll?: true
    sst?: true
  }

  export type TrackingDataSumAggregateInputType = {
    lat?: true
    lon?: true
    depth?: true
    temperature?: true
    chlorophyll?: true
    sst?: true
  }

  export type TrackingDataMinAggregateInputType = {
    id?: true
    sharkId?: true
    lat?: true
    lon?: true
    timestamp?: true
    depth?: true
    temperature?: true
    eddyId?: true
    chlorophyll?: true
    sst?: true
    createdAt?: true
  }

  export type TrackingDataMaxAggregateInputType = {
    id?: true
    sharkId?: true
    lat?: true
    lon?: true
    timestamp?: true
    depth?: true
    temperature?: true
    eddyId?: true
    chlorophyll?: true
    sst?: true
    createdAt?: true
  }

  export type TrackingDataCountAggregateInputType = {
    id?: true
    sharkId?: true
    lat?: true
    lon?: true
    timestamp?: true
    depth?: true
    temperature?: true
    eddyId?: true
    chlorophyll?: true
    sst?: true
    createdAt?: true
    _all?: true
  }

  export type TrackingDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingData to aggregate.
     */
    where?: TrackingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingData to fetch.
     */
    orderBy?: TrackingDataOrderByWithRelationInput | TrackingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrackingData
    **/
    _count?: true | TrackingDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackingDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackingDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackingDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackingDataMaxAggregateInputType
  }

  export type GetTrackingDataAggregateType<T extends TrackingDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackingData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackingData[P]>
      : GetScalarType<T[P], AggregateTrackingData[P]>
  }




  export type TrackingDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackingDataWhereInput
    orderBy?: TrackingDataOrderByWithAggregationInput | TrackingDataOrderByWithAggregationInput[]
    by: TrackingDataScalarFieldEnum[] | TrackingDataScalarFieldEnum
    having?: TrackingDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackingDataCountAggregateInputType | true
    _avg?: TrackingDataAvgAggregateInputType
    _sum?: TrackingDataSumAggregateInputType
    _min?: TrackingDataMinAggregateInputType
    _max?: TrackingDataMaxAggregateInputType
  }

  export type TrackingDataGroupByOutputType = {
    id: string
    sharkId: string
    lat: number
    lon: number
    timestamp: Date
    depth: number | null
    temperature: number | null
    eddyId: string | null
    chlorophyll: number | null
    sst: number | null
    createdAt: Date
    _count: TrackingDataCountAggregateOutputType | null
    _avg: TrackingDataAvgAggregateOutputType | null
    _sum: TrackingDataSumAggregateOutputType | null
    _min: TrackingDataMinAggregateOutputType | null
    _max: TrackingDataMaxAggregateOutputType | null
  }

  type GetTrackingDataGroupByPayload<T extends TrackingDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackingDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackingDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackingDataGroupByOutputType[P]>
            : GetScalarType<T[P], TrackingDataGroupByOutputType[P]>
        }
      >
    >


  export type TrackingDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharkId?: boolean
    lat?: boolean
    lon?: boolean
    timestamp?: boolean
    depth?: boolean
    temperature?: boolean
    eddyId?: boolean
    chlorophyll?: boolean
    sst?: boolean
    createdAt?: boolean
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingData"]>

  export type TrackingDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharkId?: boolean
    lat?: boolean
    lon?: boolean
    timestamp?: boolean
    depth?: boolean
    temperature?: boolean
    eddyId?: boolean
    chlorophyll?: boolean
    sst?: boolean
    createdAt?: boolean
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingData"]>

  export type TrackingDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sharkId?: boolean
    lat?: boolean
    lon?: boolean
    timestamp?: boolean
    depth?: boolean
    temperature?: boolean
    eddyId?: boolean
    chlorophyll?: boolean
    sst?: boolean
    createdAt?: boolean
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trackingData"]>

  export type TrackingDataSelectScalar = {
    id?: boolean
    sharkId?: boolean
    lat?: boolean
    lon?: boolean
    timestamp?: boolean
    depth?: boolean
    temperature?: boolean
    eddyId?: boolean
    chlorophyll?: boolean
    sst?: boolean
    createdAt?: boolean
  }

  export type TrackingDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sharkId" | "lat" | "lon" | "timestamp" | "depth" | "temperature" | "eddyId" | "chlorophyll" | "sst" | "createdAt", ExtArgs["result"]["trackingData"]>
  export type TrackingDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }
  export type TrackingDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }
  export type TrackingDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shark?: boolean | SharkDefaultArgs<ExtArgs>
  }

  export type $TrackingDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrackingData"
    objects: {
      shark: Prisma.$SharkPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sharkId: string
      lat: number
      lon: number
      timestamp: Date
      depth: number | null
      temperature: number | null
      eddyId: string | null
      chlorophyll: number | null
      sst: number | null
      createdAt: Date
    }, ExtArgs["result"]["trackingData"]>
    composites: {}
  }

  type TrackingDataGetPayload<S extends boolean | null | undefined | TrackingDataDefaultArgs> = $Result.GetResult<Prisma.$TrackingDataPayload, S>

  type TrackingDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrackingDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrackingDataCountAggregateInputType | true
    }

  export interface TrackingDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrackingData'], meta: { name: 'TrackingData' } }
    /**
     * Find zero or one TrackingData that matches the filter.
     * @param {TrackingDataFindUniqueArgs} args - Arguments to find a TrackingData
     * @example
     * // Get one TrackingData
     * const trackingData = await prisma.trackingData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrackingDataFindUniqueArgs>(args: SelectSubset<T, TrackingDataFindUniqueArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrackingData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrackingDataFindUniqueOrThrowArgs} args - Arguments to find a TrackingData
     * @example
     * // Get one TrackingData
     * const trackingData = await prisma.trackingData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrackingDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TrackingDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataFindFirstArgs} args - Arguments to find a TrackingData
     * @example
     * // Get one TrackingData
     * const trackingData = await prisma.trackingData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrackingDataFindFirstArgs>(args?: SelectSubset<T, TrackingDataFindFirstArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrackingData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataFindFirstOrThrowArgs} args - Arguments to find a TrackingData
     * @example
     * // Get one TrackingData
     * const trackingData = await prisma.trackingData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrackingDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TrackingDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrackingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrackingData
     * const trackingData = await prisma.trackingData.findMany()
     * 
     * // Get first 10 TrackingData
     * const trackingData = await prisma.trackingData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackingDataWithIdOnly = await prisma.trackingData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrackingDataFindManyArgs>(args?: SelectSubset<T, TrackingDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrackingData.
     * @param {TrackingDataCreateArgs} args - Arguments to create a TrackingData.
     * @example
     * // Create one TrackingData
     * const TrackingData = await prisma.trackingData.create({
     *   data: {
     *     // ... data to create a TrackingData
     *   }
     * })
     * 
     */
    create<T extends TrackingDataCreateArgs>(args: SelectSubset<T, TrackingDataCreateArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrackingData.
     * @param {TrackingDataCreateManyArgs} args - Arguments to create many TrackingData.
     * @example
     * // Create many TrackingData
     * const trackingData = await prisma.trackingData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrackingDataCreateManyArgs>(args?: SelectSubset<T, TrackingDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrackingData and returns the data saved in the database.
     * @param {TrackingDataCreateManyAndReturnArgs} args - Arguments to create many TrackingData.
     * @example
     * // Create many TrackingData
     * const trackingData = await prisma.trackingData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrackingData and only return the `id`
     * const trackingDataWithIdOnly = await prisma.trackingData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrackingDataCreateManyAndReturnArgs>(args?: SelectSubset<T, TrackingDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrackingData.
     * @param {TrackingDataDeleteArgs} args - Arguments to delete one TrackingData.
     * @example
     * // Delete one TrackingData
     * const TrackingData = await prisma.trackingData.delete({
     *   where: {
     *     // ... filter to delete one TrackingData
     *   }
     * })
     * 
     */
    delete<T extends TrackingDataDeleteArgs>(args: SelectSubset<T, TrackingDataDeleteArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrackingData.
     * @param {TrackingDataUpdateArgs} args - Arguments to update one TrackingData.
     * @example
     * // Update one TrackingData
     * const trackingData = await prisma.trackingData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrackingDataUpdateArgs>(args: SelectSubset<T, TrackingDataUpdateArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrackingData.
     * @param {TrackingDataDeleteManyArgs} args - Arguments to filter TrackingData to delete.
     * @example
     * // Delete a few TrackingData
     * const { count } = await prisma.trackingData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrackingDataDeleteManyArgs>(args?: SelectSubset<T, TrackingDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrackingData
     * const trackingData = await prisma.trackingData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrackingDataUpdateManyArgs>(args: SelectSubset<T, TrackingDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrackingData and returns the data updated in the database.
     * @param {TrackingDataUpdateManyAndReturnArgs} args - Arguments to update many TrackingData.
     * @example
     * // Update many TrackingData
     * const trackingData = await prisma.trackingData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrackingData and only return the `id`
     * const trackingDataWithIdOnly = await prisma.trackingData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrackingDataUpdateManyAndReturnArgs>(args: SelectSubset<T, TrackingDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrackingData.
     * @param {TrackingDataUpsertArgs} args - Arguments to update or create a TrackingData.
     * @example
     * // Update or create a TrackingData
     * const trackingData = await prisma.trackingData.upsert({
     *   create: {
     *     // ... data to create a TrackingData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrackingData we want to update
     *   }
     * })
     */
    upsert<T extends TrackingDataUpsertArgs>(args: SelectSubset<T, TrackingDataUpsertArgs<ExtArgs>>): Prisma__TrackingDataClient<$Result.GetResult<Prisma.$TrackingDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrackingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataCountArgs} args - Arguments to filter TrackingData to count.
     * @example
     * // Count the number of TrackingData
     * const count = await prisma.trackingData.count({
     *   where: {
     *     // ... the filter for the TrackingData we want to count
     *   }
     * })
    **/
    count<T extends TrackingDataCountArgs>(
      args?: Subset<T, TrackingDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackingDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrackingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackingDataAggregateArgs>(args: Subset<T, TrackingDataAggregateArgs>): Prisma.PrismaPromise<GetTrackingDataAggregateType<T>>

    /**
     * Group by TrackingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackingDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackingDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackingDataGroupByArgs['orderBy'] }
        : { orderBy?: TrackingDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackingDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackingDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrackingData model
   */
  readonly fields: TrackingDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrackingData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackingDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shark<T extends SharkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SharkDefaultArgs<ExtArgs>>): Prisma__SharkClient<$Result.GetResult<Prisma.$SharkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrackingData model
   */
  interface TrackingDataFieldRefs {
    readonly id: FieldRef<"TrackingData", 'String'>
    readonly sharkId: FieldRef<"TrackingData", 'String'>
    readonly lat: FieldRef<"TrackingData", 'Float'>
    readonly lon: FieldRef<"TrackingData", 'Float'>
    readonly timestamp: FieldRef<"TrackingData", 'DateTime'>
    readonly depth: FieldRef<"TrackingData", 'Float'>
    readonly temperature: FieldRef<"TrackingData", 'Float'>
    readonly eddyId: FieldRef<"TrackingData", 'String'>
    readonly chlorophyll: FieldRef<"TrackingData", 'Float'>
    readonly sst: FieldRef<"TrackingData", 'Float'>
    readonly createdAt: FieldRef<"TrackingData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrackingData findUnique
   */
  export type TrackingDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter, which TrackingData to fetch.
     */
    where: TrackingDataWhereUniqueInput
  }

  /**
   * TrackingData findUniqueOrThrow
   */
  export type TrackingDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter, which TrackingData to fetch.
     */
    where: TrackingDataWhereUniqueInput
  }

  /**
   * TrackingData findFirst
   */
  export type TrackingDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter, which TrackingData to fetch.
     */
    where?: TrackingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingData to fetch.
     */
    orderBy?: TrackingDataOrderByWithRelationInput | TrackingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingData.
     */
    cursor?: TrackingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingData.
     */
    distinct?: TrackingDataScalarFieldEnum | TrackingDataScalarFieldEnum[]
  }

  /**
   * TrackingData findFirstOrThrow
   */
  export type TrackingDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter, which TrackingData to fetch.
     */
    where?: TrackingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingData to fetch.
     */
    orderBy?: TrackingDataOrderByWithRelationInput | TrackingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrackingData.
     */
    cursor?: TrackingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrackingData.
     */
    distinct?: TrackingDataScalarFieldEnum | TrackingDataScalarFieldEnum[]
  }

  /**
   * TrackingData findMany
   */
  export type TrackingDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter, which TrackingData to fetch.
     */
    where?: TrackingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrackingData to fetch.
     */
    orderBy?: TrackingDataOrderByWithRelationInput | TrackingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrackingData.
     */
    cursor?: TrackingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrackingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrackingData.
     */
    skip?: number
    distinct?: TrackingDataScalarFieldEnum | TrackingDataScalarFieldEnum[]
  }

  /**
   * TrackingData create
   */
  export type TrackingDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * The data needed to create a TrackingData.
     */
    data: XOR<TrackingDataCreateInput, TrackingDataUncheckedCreateInput>
  }

  /**
   * TrackingData createMany
   */
  export type TrackingDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrackingData.
     */
    data: TrackingDataCreateManyInput | TrackingDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrackingData createManyAndReturn
   */
  export type TrackingDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * The data used to create many TrackingData.
     */
    data: TrackingDataCreateManyInput | TrackingDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingData update
   */
  export type TrackingDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * The data needed to update a TrackingData.
     */
    data: XOR<TrackingDataUpdateInput, TrackingDataUncheckedUpdateInput>
    /**
     * Choose, which TrackingData to update.
     */
    where: TrackingDataWhereUniqueInput
  }

  /**
   * TrackingData updateMany
   */
  export type TrackingDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrackingData.
     */
    data: XOR<TrackingDataUpdateManyMutationInput, TrackingDataUncheckedUpdateManyInput>
    /**
     * Filter which TrackingData to update
     */
    where?: TrackingDataWhereInput
    /**
     * Limit how many TrackingData to update.
     */
    limit?: number
  }

  /**
   * TrackingData updateManyAndReturn
   */
  export type TrackingDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * The data used to update TrackingData.
     */
    data: XOR<TrackingDataUpdateManyMutationInput, TrackingDataUncheckedUpdateManyInput>
    /**
     * Filter which TrackingData to update
     */
    where?: TrackingDataWhereInput
    /**
     * Limit how many TrackingData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrackingData upsert
   */
  export type TrackingDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * The filter to search for the TrackingData to update in case it exists.
     */
    where: TrackingDataWhereUniqueInput
    /**
     * In case the TrackingData found by the `where` argument doesn't exist, create a new TrackingData with this data.
     */
    create: XOR<TrackingDataCreateInput, TrackingDataUncheckedCreateInput>
    /**
     * In case the TrackingData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackingDataUpdateInput, TrackingDataUncheckedUpdateInput>
  }

  /**
   * TrackingData delete
   */
  export type TrackingDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
    /**
     * Filter which TrackingData to delete.
     */
    where: TrackingDataWhereUniqueInput
  }

  /**
   * TrackingData deleteMany
   */
  export type TrackingDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrackingData to delete
     */
    where?: TrackingDataWhereInput
    /**
     * Limit how many TrackingData to delete.
     */
    limit?: number
  }

  /**
   * TrackingData without action
   */
  export type TrackingDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackingData
     */
    select?: TrackingDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrackingData
     */
    omit?: TrackingDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrackingDataInclude<ExtArgs> | null
  }


  /**
   * Model SharkHotspot
   */

  export type AggregateSharkHotspot = {
    _count: SharkHotspotCountAggregateOutputType | null
    _avg: SharkHotspotAvgAggregateOutputType | null
    _sum: SharkHotspotSumAggregateOutputType | null
    _min: SharkHotspotMinAggregateOutputType | null
    _max: SharkHotspotMaxAggregateOutputType | null
  }

  export type SharkHotspotAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    count: number | null
    avgTemp: number | null
    avgChl: number | null
  }

  export type SharkHotspotSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    count: number | null
    avgTemp: number | null
    avgChl: number | null
  }

  export type SharkHotspotMinAggregateOutputType = {
    id: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    count: number | null
    avgTemp: number | null
    avgChl: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type SharkHotspotMaxAggregateOutputType = {
    id: string | null
    region: string | null
    latitude: number | null
    longitude: number | null
    count: number | null
    avgTemp: number | null
    avgChl: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type SharkHotspotCountAggregateOutputType = {
    id: number
    region: number
    latitude: number
    longitude: number
    count: number
    avgTemp: number
    avgChl: number
    startTime: number
    endTime: number
    createdAt: number
    _all: number
  }


  export type SharkHotspotAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    count?: true
    avgTemp?: true
    avgChl?: true
  }

  export type SharkHotspotSumAggregateInputType = {
    latitude?: true
    longitude?: true
    count?: true
    avgTemp?: true
    avgChl?: true
  }

  export type SharkHotspotMinAggregateInputType = {
    id?: true
    region?: true
    latitude?: true
    longitude?: true
    count?: true
    avgTemp?: true
    avgChl?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type SharkHotspotMaxAggregateInputType = {
    id?: true
    region?: true
    latitude?: true
    longitude?: true
    count?: true
    avgTemp?: true
    avgChl?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type SharkHotspotCountAggregateInputType = {
    id?: true
    region?: true
    latitude?: true
    longitude?: true
    count?: true
    avgTemp?: true
    avgChl?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    _all?: true
  }

  export type SharkHotspotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharkHotspot to aggregate.
     */
    where?: SharkHotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkHotspots to fetch.
     */
    orderBy?: SharkHotspotOrderByWithRelationInput | SharkHotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharkHotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkHotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkHotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharkHotspots
    **/
    _count?: true | SharkHotspotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharkHotspotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharkHotspotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharkHotspotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharkHotspotMaxAggregateInputType
  }

  export type GetSharkHotspotAggregateType<T extends SharkHotspotAggregateArgs> = {
        [P in keyof T & keyof AggregateSharkHotspot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharkHotspot[P]>
      : GetScalarType<T[P], AggregateSharkHotspot[P]>
  }




  export type SharkHotspotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharkHotspotWhereInput
    orderBy?: SharkHotspotOrderByWithAggregationInput | SharkHotspotOrderByWithAggregationInput[]
    by: SharkHotspotScalarFieldEnum[] | SharkHotspotScalarFieldEnum
    having?: SharkHotspotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharkHotspotCountAggregateInputType | true
    _avg?: SharkHotspotAvgAggregateInputType
    _sum?: SharkHotspotSumAggregateInputType
    _min?: SharkHotspotMinAggregateInputType
    _max?: SharkHotspotMaxAggregateInputType
  }

  export type SharkHotspotGroupByOutputType = {
    id: string
    region: string
    latitude: number
    longitude: number
    count: number
    avgTemp: number | null
    avgChl: number | null
    startTime: Date
    endTime: Date
    createdAt: Date
    _count: SharkHotspotCountAggregateOutputType | null
    _avg: SharkHotspotAvgAggregateOutputType | null
    _sum: SharkHotspotSumAggregateOutputType | null
    _min: SharkHotspotMinAggregateOutputType | null
    _max: SharkHotspotMaxAggregateOutputType | null
  }

  type GetSharkHotspotGroupByPayload<T extends SharkHotspotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharkHotspotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharkHotspotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharkHotspotGroupByOutputType[P]>
            : GetScalarType<T[P], SharkHotspotGroupByOutputType[P]>
        }
      >
    >


  export type SharkHotspotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    count?: boolean
    avgTemp?: boolean
    avgChl?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkHotspot"]>

  export type SharkHotspotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    count?: boolean
    avgTemp?: boolean
    avgChl?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkHotspot"]>

  export type SharkHotspotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    count?: boolean
    avgTemp?: boolean
    avgChl?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkHotspot"]>

  export type SharkHotspotSelectScalar = {
    id?: boolean
    region?: boolean
    latitude?: boolean
    longitude?: boolean
    count?: boolean
    avgTemp?: boolean
    avgChl?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }

  export type SharkHotspotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "region" | "latitude" | "longitude" | "count" | "avgTemp" | "avgChl" | "startTime" | "endTime" | "createdAt", ExtArgs["result"]["sharkHotspot"]>

  export type $SharkHotspotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharkHotspot"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      region: string
      latitude: number
      longitude: number
      count: number
      avgTemp: number | null
      avgChl: number | null
      startTime: Date
      endTime: Date
      createdAt: Date
    }, ExtArgs["result"]["sharkHotspot"]>
    composites: {}
  }

  type SharkHotspotGetPayload<S extends boolean | null | undefined | SharkHotspotDefaultArgs> = $Result.GetResult<Prisma.$SharkHotspotPayload, S>

  type SharkHotspotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharkHotspotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharkHotspotCountAggregateInputType | true
    }

  export interface SharkHotspotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharkHotspot'], meta: { name: 'SharkHotspot' } }
    /**
     * Find zero or one SharkHotspot that matches the filter.
     * @param {SharkHotspotFindUniqueArgs} args - Arguments to find a SharkHotspot
     * @example
     * // Get one SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharkHotspotFindUniqueArgs>(args: SelectSubset<T, SharkHotspotFindUniqueArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharkHotspot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharkHotspotFindUniqueOrThrowArgs} args - Arguments to find a SharkHotspot
     * @example
     * // Get one SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharkHotspotFindUniqueOrThrowArgs>(args: SelectSubset<T, SharkHotspotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharkHotspot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotFindFirstArgs} args - Arguments to find a SharkHotspot
     * @example
     * // Get one SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharkHotspotFindFirstArgs>(args?: SelectSubset<T, SharkHotspotFindFirstArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharkHotspot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotFindFirstOrThrowArgs} args - Arguments to find a SharkHotspot
     * @example
     * // Get one SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharkHotspotFindFirstOrThrowArgs>(args?: SelectSubset<T, SharkHotspotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharkHotspots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharkHotspots
     * const sharkHotspots = await prisma.sharkHotspot.findMany()
     * 
     * // Get first 10 SharkHotspots
     * const sharkHotspots = await prisma.sharkHotspot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharkHotspotWithIdOnly = await prisma.sharkHotspot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharkHotspotFindManyArgs>(args?: SelectSubset<T, SharkHotspotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharkHotspot.
     * @param {SharkHotspotCreateArgs} args - Arguments to create a SharkHotspot.
     * @example
     * // Create one SharkHotspot
     * const SharkHotspot = await prisma.sharkHotspot.create({
     *   data: {
     *     // ... data to create a SharkHotspot
     *   }
     * })
     * 
     */
    create<T extends SharkHotspotCreateArgs>(args: SelectSubset<T, SharkHotspotCreateArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharkHotspots.
     * @param {SharkHotspotCreateManyArgs} args - Arguments to create many SharkHotspots.
     * @example
     * // Create many SharkHotspots
     * const sharkHotspot = await prisma.sharkHotspot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharkHotspotCreateManyArgs>(args?: SelectSubset<T, SharkHotspotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharkHotspots and returns the data saved in the database.
     * @param {SharkHotspotCreateManyAndReturnArgs} args - Arguments to create many SharkHotspots.
     * @example
     * // Create many SharkHotspots
     * const sharkHotspot = await prisma.sharkHotspot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharkHotspots and only return the `id`
     * const sharkHotspotWithIdOnly = await prisma.sharkHotspot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharkHotspotCreateManyAndReturnArgs>(args?: SelectSubset<T, SharkHotspotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharkHotspot.
     * @param {SharkHotspotDeleteArgs} args - Arguments to delete one SharkHotspot.
     * @example
     * // Delete one SharkHotspot
     * const SharkHotspot = await prisma.sharkHotspot.delete({
     *   where: {
     *     // ... filter to delete one SharkHotspot
     *   }
     * })
     * 
     */
    delete<T extends SharkHotspotDeleteArgs>(args: SelectSubset<T, SharkHotspotDeleteArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharkHotspot.
     * @param {SharkHotspotUpdateArgs} args - Arguments to update one SharkHotspot.
     * @example
     * // Update one SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharkHotspotUpdateArgs>(args: SelectSubset<T, SharkHotspotUpdateArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharkHotspots.
     * @param {SharkHotspotDeleteManyArgs} args - Arguments to filter SharkHotspots to delete.
     * @example
     * // Delete a few SharkHotspots
     * const { count } = await prisma.sharkHotspot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharkHotspotDeleteManyArgs>(args?: SelectSubset<T, SharkHotspotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharkHotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharkHotspots
     * const sharkHotspot = await prisma.sharkHotspot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharkHotspotUpdateManyArgs>(args: SelectSubset<T, SharkHotspotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharkHotspots and returns the data updated in the database.
     * @param {SharkHotspotUpdateManyAndReturnArgs} args - Arguments to update many SharkHotspots.
     * @example
     * // Update many SharkHotspots
     * const sharkHotspot = await prisma.sharkHotspot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharkHotspots and only return the `id`
     * const sharkHotspotWithIdOnly = await prisma.sharkHotspot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharkHotspotUpdateManyAndReturnArgs>(args: SelectSubset<T, SharkHotspotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharkHotspot.
     * @param {SharkHotspotUpsertArgs} args - Arguments to update or create a SharkHotspot.
     * @example
     * // Update or create a SharkHotspot
     * const sharkHotspot = await prisma.sharkHotspot.upsert({
     *   create: {
     *     // ... data to create a SharkHotspot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharkHotspot we want to update
     *   }
     * })
     */
    upsert<T extends SharkHotspotUpsertArgs>(args: SelectSubset<T, SharkHotspotUpsertArgs<ExtArgs>>): Prisma__SharkHotspotClient<$Result.GetResult<Prisma.$SharkHotspotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharkHotspots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotCountArgs} args - Arguments to filter SharkHotspots to count.
     * @example
     * // Count the number of SharkHotspots
     * const count = await prisma.sharkHotspot.count({
     *   where: {
     *     // ... the filter for the SharkHotspots we want to count
     *   }
     * })
    **/
    count<T extends SharkHotspotCountArgs>(
      args?: Subset<T, SharkHotspotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharkHotspotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharkHotspot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharkHotspotAggregateArgs>(args: Subset<T, SharkHotspotAggregateArgs>): Prisma.PrismaPromise<GetSharkHotspotAggregateType<T>>

    /**
     * Group by SharkHotspot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkHotspotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharkHotspotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharkHotspotGroupByArgs['orderBy'] }
        : { orderBy?: SharkHotspotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharkHotspotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharkHotspotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharkHotspot model
   */
  readonly fields: SharkHotspotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharkHotspot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharkHotspotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharkHotspot model
   */
  interface SharkHotspotFieldRefs {
    readonly id: FieldRef<"SharkHotspot", 'String'>
    readonly region: FieldRef<"SharkHotspot", 'String'>
    readonly latitude: FieldRef<"SharkHotspot", 'Float'>
    readonly longitude: FieldRef<"SharkHotspot", 'Float'>
    readonly count: FieldRef<"SharkHotspot", 'Int'>
    readonly avgTemp: FieldRef<"SharkHotspot", 'Float'>
    readonly avgChl: FieldRef<"SharkHotspot", 'Float'>
    readonly startTime: FieldRef<"SharkHotspot", 'DateTime'>
    readonly endTime: FieldRef<"SharkHotspot", 'DateTime'>
    readonly createdAt: FieldRef<"SharkHotspot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharkHotspot findUnique
   */
  export type SharkHotspotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter, which SharkHotspot to fetch.
     */
    where: SharkHotspotWhereUniqueInput
  }

  /**
   * SharkHotspot findUniqueOrThrow
   */
  export type SharkHotspotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter, which SharkHotspot to fetch.
     */
    where: SharkHotspotWhereUniqueInput
  }

  /**
   * SharkHotspot findFirst
   */
  export type SharkHotspotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter, which SharkHotspot to fetch.
     */
    where?: SharkHotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkHotspots to fetch.
     */
    orderBy?: SharkHotspotOrderByWithRelationInput | SharkHotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharkHotspots.
     */
    cursor?: SharkHotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkHotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkHotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharkHotspots.
     */
    distinct?: SharkHotspotScalarFieldEnum | SharkHotspotScalarFieldEnum[]
  }

  /**
   * SharkHotspot findFirstOrThrow
   */
  export type SharkHotspotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter, which SharkHotspot to fetch.
     */
    where?: SharkHotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkHotspots to fetch.
     */
    orderBy?: SharkHotspotOrderByWithRelationInput | SharkHotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharkHotspots.
     */
    cursor?: SharkHotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkHotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkHotspots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharkHotspots.
     */
    distinct?: SharkHotspotScalarFieldEnum | SharkHotspotScalarFieldEnum[]
  }

  /**
   * SharkHotspot findMany
   */
  export type SharkHotspotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter, which SharkHotspots to fetch.
     */
    where?: SharkHotspotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkHotspots to fetch.
     */
    orderBy?: SharkHotspotOrderByWithRelationInput | SharkHotspotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharkHotspots.
     */
    cursor?: SharkHotspotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkHotspots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkHotspots.
     */
    skip?: number
    distinct?: SharkHotspotScalarFieldEnum | SharkHotspotScalarFieldEnum[]
  }

  /**
   * SharkHotspot create
   */
  export type SharkHotspotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * The data needed to create a SharkHotspot.
     */
    data: XOR<SharkHotspotCreateInput, SharkHotspotUncheckedCreateInput>
  }

  /**
   * SharkHotspot createMany
   */
  export type SharkHotspotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharkHotspots.
     */
    data: SharkHotspotCreateManyInput | SharkHotspotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharkHotspot createManyAndReturn
   */
  export type SharkHotspotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * The data used to create many SharkHotspots.
     */
    data: SharkHotspotCreateManyInput | SharkHotspotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharkHotspot update
   */
  export type SharkHotspotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * The data needed to update a SharkHotspot.
     */
    data: XOR<SharkHotspotUpdateInput, SharkHotspotUncheckedUpdateInput>
    /**
     * Choose, which SharkHotspot to update.
     */
    where: SharkHotspotWhereUniqueInput
  }

  /**
   * SharkHotspot updateMany
   */
  export type SharkHotspotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharkHotspots.
     */
    data: XOR<SharkHotspotUpdateManyMutationInput, SharkHotspotUncheckedUpdateManyInput>
    /**
     * Filter which SharkHotspots to update
     */
    where?: SharkHotspotWhereInput
    /**
     * Limit how many SharkHotspots to update.
     */
    limit?: number
  }

  /**
   * SharkHotspot updateManyAndReturn
   */
  export type SharkHotspotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * The data used to update SharkHotspots.
     */
    data: XOR<SharkHotspotUpdateManyMutationInput, SharkHotspotUncheckedUpdateManyInput>
    /**
     * Filter which SharkHotspots to update
     */
    where?: SharkHotspotWhereInput
    /**
     * Limit how many SharkHotspots to update.
     */
    limit?: number
  }

  /**
   * SharkHotspot upsert
   */
  export type SharkHotspotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * The filter to search for the SharkHotspot to update in case it exists.
     */
    where: SharkHotspotWhereUniqueInput
    /**
     * In case the SharkHotspot found by the `where` argument doesn't exist, create a new SharkHotspot with this data.
     */
    create: XOR<SharkHotspotCreateInput, SharkHotspotUncheckedCreateInput>
    /**
     * In case the SharkHotspot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharkHotspotUpdateInput, SharkHotspotUncheckedUpdateInput>
  }

  /**
   * SharkHotspot delete
   */
  export type SharkHotspotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
    /**
     * Filter which SharkHotspot to delete.
     */
    where: SharkHotspotWhereUniqueInput
  }

  /**
   * SharkHotspot deleteMany
   */
  export type SharkHotspotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharkHotspots to delete
     */
    where?: SharkHotspotWhereInput
    /**
     * Limit how many SharkHotspots to delete.
     */
    limit?: number
  }

  /**
   * SharkHotspot without action
   */
  export type SharkHotspotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkHotspot
     */
    select?: SharkHotspotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkHotspot
     */
    omit?: SharkHotspotOmit<ExtArgs> | null
  }


  /**
   * Model SharkSeasonalStats
   */

  export type AggregateSharkSeasonalStats = {
    _count: SharkSeasonalStatsCountAggregateOutputType | null
    _avg: SharkSeasonalStatsAvgAggregateOutputType | null
    _sum: SharkSeasonalStatsSumAggregateOutputType | null
    _min: SharkSeasonalStatsMinAggregateOutputType | null
    _max: SharkSeasonalStatsMaxAggregateOutputType | null
  }

  export type SharkSeasonalStatsAvgAggregateOutputType = {
    totalTags: number | null
    uniqueSharks: number | null
    avgSpeed: number | null
    hotspotCount: number | null
  }

  export type SharkSeasonalStatsSumAggregateOutputType = {
    totalTags: number | null
    uniqueSharks: number | null
    avgSpeed: number | null
    hotspotCount: number | null
  }

  export type SharkSeasonalStatsMinAggregateOutputType = {
    id: string | null
    season: string | null
    totalTags: number | null
    uniqueSharks: number | null
    avgSpeed: number | null
    hotspotCount: number | null
    createdAt: Date | null
  }

  export type SharkSeasonalStatsMaxAggregateOutputType = {
    id: string | null
    season: string | null
    totalTags: number | null
    uniqueSharks: number | null
    avgSpeed: number | null
    hotspotCount: number | null
    createdAt: Date | null
  }

  export type SharkSeasonalStatsCountAggregateOutputType = {
    id: number
    season: number
    totalTags: number
    uniqueSharks: number
    avgSpeed: number
    hotspotCount: number
    createdAt: number
    _all: number
  }


  export type SharkSeasonalStatsAvgAggregateInputType = {
    totalTags?: true
    uniqueSharks?: true
    avgSpeed?: true
    hotspotCount?: true
  }

  export type SharkSeasonalStatsSumAggregateInputType = {
    totalTags?: true
    uniqueSharks?: true
    avgSpeed?: true
    hotspotCount?: true
  }

  export type SharkSeasonalStatsMinAggregateInputType = {
    id?: true
    season?: true
    totalTags?: true
    uniqueSharks?: true
    avgSpeed?: true
    hotspotCount?: true
    createdAt?: true
  }

  export type SharkSeasonalStatsMaxAggregateInputType = {
    id?: true
    season?: true
    totalTags?: true
    uniqueSharks?: true
    avgSpeed?: true
    hotspotCount?: true
    createdAt?: true
  }

  export type SharkSeasonalStatsCountAggregateInputType = {
    id?: true
    season?: true
    totalTags?: true
    uniqueSharks?: true
    avgSpeed?: true
    hotspotCount?: true
    createdAt?: true
    _all?: true
  }

  export type SharkSeasonalStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharkSeasonalStats to aggregate.
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkSeasonalStats to fetch.
     */
    orderBy?: SharkSeasonalStatsOrderByWithRelationInput | SharkSeasonalStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharkSeasonalStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkSeasonalStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkSeasonalStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharkSeasonalStats
    **/
    _count?: true | SharkSeasonalStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharkSeasonalStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharkSeasonalStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharkSeasonalStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharkSeasonalStatsMaxAggregateInputType
  }

  export type GetSharkSeasonalStatsAggregateType<T extends SharkSeasonalStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateSharkSeasonalStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharkSeasonalStats[P]>
      : GetScalarType<T[P], AggregateSharkSeasonalStats[P]>
  }




  export type SharkSeasonalStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharkSeasonalStatsWhereInput
    orderBy?: SharkSeasonalStatsOrderByWithAggregationInput | SharkSeasonalStatsOrderByWithAggregationInput[]
    by: SharkSeasonalStatsScalarFieldEnum[] | SharkSeasonalStatsScalarFieldEnum
    having?: SharkSeasonalStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharkSeasonalStatsCountAggregateInputType | true
    _avg?: SharkSeasonalStatsAvgAggregateInputType
    _sum?: SharkSeasonalStatsSumAggregateInputType
    _min?: SharkSeasonalStatsMinAggregateInputType
    _max?: SharkSeasonalStatsMaxAggregateInputType
  }

  export type SharkSeasonalStatsGroupByOutputType = {
    id: string
    season: string
    totalTags: number
    uniqueSharks: number
    avgSpeed: number | null
    hotspotCount: number
    createdAt: Date
    _count: SharkSeasonalStatsCountAggregateOutputType | null
    _avg: SharkSeasonalStatsAvgAggregateOutputType | null
    _sum: SharkSeasonalStatsSumAggregateOutputType | null
    _min: SharkSeasonalStatsMinAggregateOutputType | null
    _max: SharkSeasonalStatsMaxAggregateOutputType | null
  }

  type GetSharkSeasonalStatsGroupByPayload<T extends SharkSeasonalStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharkSeasonalStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharkSeasonalStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharkSeasonalStatsGroupByOutputType[P]>
            : GetScalarType<T[P], SharkSeasonalStatsGroupByOutputType[P]>
        }
      >
    >


  export type SharkSeasonalStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    totalTags?: boolean
    uniqueSharks?: boolean
    avgSpeed?: boolean
    hotspotCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkSeasonalStats"]>

  export type SharkSeasonalStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    totalTags?: boolean
    uniqueSharks?: boolean
    avgSpeed?: boolean
    hotspotCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkSeasonalStats"]>

  export type SharkSeasonalStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    season?: boolean
    totalTags?: boolean
    uniqueSharks?: boolean
    avgSpeed?: boolean
    hotspotCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sharkSeasonalStats"]>

  export type SharkSeasonalStatsSelectScalar = {
    id?: boolean
    season?: boolean
    totalTags?: boolean
    uniqueSharks?: boolean
    avgSpeed?: boolean
    hotspotCount?: boolean
    createdAt?: boolean
  }

  export type SharkSeasonalStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "season" | "totalTags" | "uniqueSharks" | "avgSpeed" | "hotspotCount" | "createdAt", ExtArgs["result"]["sharkSeasonalStats"]>

  export type $SharkSeasonalStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharkSeasonalStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      season: string
      totalTags: number
      uniqueSharks: number
      avgSpeed: number | null
      hotspotCount: number
      createdAt: Date
    }, ExtArgs["result"]["sharkSeasonalStats"]>
    composites: {}
  }

  type SharkSeasonalStatsGetPayload<S extends boolean | null | undefined | SharkSeasonalStatsDefaultArgs> = $Result.GetResult<Prisma.$SharkSeasonalStatsPayload, S>

  type SharkSeasonalStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharkSeasonalStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharkSeasonalStatsCountAggregateInputType | true
    }

  export interface SharkSeasonalStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharkSeasonalStats'], meta: { name: 'SharkSeasonalStats' } }
    /**
     * Find zero or one SharkSeasonalStats that matches the filter.
     * @param {SharkSeasonalStatsFindUniqueArgs} args - Arguments to find a SharkSeasonalStats
     * @example
     * // Get one SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharkSeasonalStatsFindUniqueArgs>(args: SelectSubset<T, SharkSeasonalStatsFindUniqueArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharkSeasonalStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharkSeasonalStatsFindUniqueOrThrowArgs} args - Arguments to find a SharkSeasonalStats
     * @example
     * // Get one SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharkSeasonalStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, SharkSeasonalStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharkSeasonalStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsFindFirstArgs} args - Arguments to find a SharkSeasonalStats
     * @example
     * // Get one SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharkSeasonalStatsFindFirstArgs>(args?: SelectSubset<T, SharkSeasonalStatsFindFirstArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharkSeasonalStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsFindFirstOrThrowArgs} args - Arguments to find a SharkSeasonalStats
     * @example
     * // Get one SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharkSeasonalStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, SharkSeasonalStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharkSeasonalStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findMany()
     * 
     * // Get first 10 SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharkSeasonalStatsWithIdOnly = await prisma.sharkSeasonalStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharkSeasonalStatsFindManyArgs>(args?: SelectSubset<T, SharkSeasonalStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharkSeasonalStats.
     * @param {SharkSeasonalStatsCreateArgs} args - Arguments to create a SharkSeasonalStats.
     * @example
     * // Create one SharkSeasonalStats
     * const SharkSeasonalStats = await prisma.sharkSeasonalStats.create({
     *   data: {
     *     // ... data to create a SharkSeasonalStats
     *   }
     * })
     * 
     */
    create<T extends SharkSeasonalStatsCreateArgs>(args: SelectSubset<T, SharkSeasonalStatsCreateArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharkSeasonalStats.
     * @param {SharkSeasonalStatsCreateManyArgs} args - Arguments to create many SharkSeasonalStats.
     * @example
     * // Create many SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharkSeasonalStatsCreateManyArgs>(args?: SelectSubset<T, SharkSeasonalStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharkSeasonalStats and returns the data saved in the database.
     * @param {SharkSeasonalStatsCreateManyAndReturnArgs} args - Arguments to create many SharkSeasonalStats.
     * @example
     * // Create many SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharkSeasonalStats and only return the `id`
     * const sharkSeasonalStatsWithIdOnly = await prisma.sharkSeasonalStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharkSeasonalStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, SharkSeasonalStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharkSeasonalStats.
     * @param {SharkSeasonalStatsDeleteArgs} args - Arguments to delete one SharkSeasonalStats.
     * @example
     * // Delete one SharkSeasonalStats
     * const SharkSeasonalStats = await prisma.sharkSeasonalStats.delete({
     *   where: {
     *     // ... filter to delete one SharkSeasonalStats
     *   }
     * })
     * 
     */
    delete<T extends SharkSeasonalStatsDeleteArgs>(args: SelectSubset<T, SharkSeasonalStatsDeleteArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharkSeasonalStats.
     * @param {SharkSeasonalStatsUpdateArgs} args - Arguments to update one SharkSeasonalStats.
     * @example
     * // Update one SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharkSeasonalStatsUpdateArgs>(args: SelectSubset<T, SharkSeasonalStatsUpdateArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharkSeasonalStats.
     * @param {SharkSeasonalStatsDeleteManyArgs} args - Arguments to filter SharkSeasonalStats to delete.
     * @example
     * // Delete a few SharkSeasonalStats
     * const { count } = await prisma.sharkSeasonalStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharkSeasonalStatsDeleteManyArgs>(args?: SelectSubset<T, SharkSeasonalStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharkSeasonalStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharkSeasonalStatsUpdateManyArgs>(args: SelectSubset<T, SharkSeasonalStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharkSeasonalStats and returns the data updated in the database.
     * @param {SharkSeasonalStatsUpdateManyAndReturnArgs} args - Arguments to update many SharkSeasonalStats.
     * @example
     * // Update many SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharkSeasonalStats and only return the `id`
     * const sharkSeasonalStatsWithIdOnly = await prisma.sharkSeasonalStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharkSeasonalStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, SharkSeasonalStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharkSeasonalStats.
     * @param {SharkSeasonalStatsUpsertArgs} args - Arguments to update or create a SharkSeasonalStats.
     * @example
     * // Update or create a SharkSeasonalStats
     * const sharkSeasonalStats = await prisma.sharkSeasonalStats.upsert({
     *   create: {
     *     // ... data to create a SharkSeasonalStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharkSeasonalStats we want to update
     *   }
     * })
     */
    upsert<T extends SharkSeasonalStatsUpsertArgs>(args: SelectSubset<T, SharkSeasonalStatsUpsertArgs<ExtArgs>>): Prisma__SharkSeasonalStatsClient<$Result.GetResult<Prisma.$SharkSeasonalStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharkSeasonalStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsCountArgs} args - Arguments to filter SharkSeasonalStats to count.
     * @example
     * // Count the number of SharkSeasonalStats
     * const count = await prisma.sharkSeasonalStats.count({
     *   where: {
     *     // ... the filter for the SharkSeasonalStats we want to count
     *   }
     * })
    **/
    count<T extends SharkSeasonalStatsCountArgs>(
      args?: Subset<T, SharkSeasonalStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharkSeasonalStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharkSeasonalStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharkSeasonalStatsAggregateArgs>(args: Subset<T, SharkSeasonalStatsAggregateArgs>): Prisma.PrismaPromise<GetSharkSeasonalStatsAggregateType<T>>

    /**
     * Group by SharkSeasonalStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharkSeasonalStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharkSeasonalStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharkSeasonalStatsGroupByArgs['orderBy'] }
        : { orderBy?: SharkSeasonalStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharkSeasonalStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharkSeasonalStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharkSeasonalStats model
   */
  readonly fields: SharkSeasonalStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharkSeasonalStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharkSeasonalStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharkSeasonalStats model
   */
  interface SharkSeasonalStatsFieldRefs {
    readonly id: FieldRef<"SharkSeasonalStats", 'String'>
    readonly season: FieldRef<"SharkSeasonalStats", 'String'>
    readonly totalTags: FieldRef<"SharkSeasonalStats", 'Int'>
    readonly uniqueSharks: FieldRef<"SharkSeasonalStats", 'Int'>
    readonly avgSpeed: FieldRef<"SharkSeasonalStats", 'Float'>
    readonly hotspotCount: FieldRef<"SharkSeasonalStats", 'Int'>
    readonly createdAt: FieldRef<"SharkSeasonalStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharkSeasonalStats findUnique
   */
  export type SharkSeasonalStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter, which SharkSeasonalStats to fetch.
     */
    where: SharkSeasonalStatsWhereUniqueInput
  }

  /**
   * SharkSeasonalStats findUniqueOrThrow
   */
  export type SharkSeasonalStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter, which SharkSeasonalStats to fetch.
     */
    where: SharkSeasonalStatsWhereUniqueInput
  }

  /**
   * SharkSeasonalStats findFirst
   */
  export type SharkSeasonalStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter, which SharkSeasonalStats to fetch.
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkSeasonalStats to fetch.
     */
    orderBy?: SharkSeasonalStatsOrderByWithRelationInput | SharkSeasonalStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharkSeasonalStats.
     */
    cursor?: SharkSeasonalStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkSeasonalStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkSeasonalStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharkSeasonalStats.
     */
    distinct?: SharkSeasonalStatsScalarFieldEnum | SharkSeasonalStatsScalarFieldEnum[]
  }

  /**
   * SharkSeasonalStats findFirstOrThrow
   */
  export type SharkSeasonalStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter, which SharkSeasonalStats to fetch.
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkSeasonalStats to fetch.
     */
    orderBy?: SharkSeasonalStatsOrderByWithRelationInput | SharkSeasonalStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharkSeasonalStats.
     */
    cursor?: SharkSeasonalStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkSeasonalStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkSeasonalStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharkSeasonalStats.
     */
    distinct?: SharkSeasonalStatsScalarFieldEnum | SharkSeasonalStatsScalarFieldEnum[]
  }

  /**
   * SharkSeasonalStats findMany
   */
  export type SharkSeasonalStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter, which SharkSeasonalStats to fetch.
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharkSeasonalStats to fetch.
     */
    orderBy?: SharkSeasonalStatsOrderByWithRelationInput | SharkSeasonalStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharkSeasonalStats.
     */
    cursor?: SharkSeasonalStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharkSeasonalStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharkSeasonalStats.
     */
    skip?: number
    distinct?: SharkSeasonalStatsScalarFieldEnum | SharkSeasonalStatsScalarFieldEnum[]
  }

  /**
   * SharkSeasonalStats create
   */
  export type SharkSeasonalStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a SharkSeasonalStats.
     */
    data: XOR<SharkSeasonalStatsCreateInput, SharkSeasonalStatsUncheckedCreateInput>
  }

  /**
   * SharkSeasonalStats createMany
   */
  export type SharkSeasonalStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharkSeasonalStats.
     */
    data: SharkSeasonalStatsCreateManyInput | SharkSeasonalStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharkSeasonalStats createManyAndReturn
   */
  export type SharkSeasonalStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * The data used to create many SharkSeasonalStats.
     */
    data: SharkSeasonalStatsCreateManyInput | SharkSeasonalStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharkSeasonalStats update
   */
  export type SharkSeasonalStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a SharkSeasonalStats.
     */
    data: XOR<SharkSeasonalStatsUpdateInput, SharkSeasonalStatsUncheckedUpdateInput>
    /**
     * Choose, which SharkSeasonalStats to update.
     */
    where: SharkSeasonalStatsWhereUniqueInput
  }

  /**
   * SharkSeasonalStats updateMany
   */
  export type SharkSeasonalStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharkSeasonalStats.
     */
    data: XOR<SharkSeasonalStatsUpdateManyMutationInput, SharkSeasonalStatsUncheckedUpdateManyInput>
    /**
     * Filter which SharkSeasonalStats to update
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * Limit how many SharkSeasonalStats to update.
     */
    limit?: number
  }

  /**
   * SharkSeasonalStats updateManyAndReturn
   */
  export type SharkSeasonalStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * The data used to update SharkSeasonalStats.
     */
    data: XOR<SharkSeasonalStatsUpdateManyMutationInput, SharkSeasonalStatsUncheckedUpdateManyInput>
    /**
     * Filter which SharkSeasonalStats to update
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * Limit how many SharkSeasonalStats to update.
     */
    limit?: number
  }

  /**
   * SharkSeasonalStats upsert
   */
  export type SharkSeasonalStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the SharkSeasonalStats to update in case it exists.
     */
    where: SharkSeasonalStatsWhereUniqueInput
    /**
     * In case the SharkSeasonalStats found by the `where` argument doesn't exist, create a new SharkSeasonalStats with this data.
     */
    create: XOR<SharkSeasonalStatsCreateInput, SharkSeasonalStatsUncheckedCreateInput>
    /**
     * In case the SharkSeasonalStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharkSeasonalStatsUpdateInput, SharkSeasonalStatsUncheckedUpdateInput>
  }

  /**
   * SharkSeasonalStats delete
   */
  export type SharkSeasonalStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
    /**
     * Filter which SharkSeasonalStats to delete.
     */
    where: SharkSeasonalStatsWhereUniqueInput
  }

  /**
   * SharkSeasonalStats deleteMany
   */
  export type SharkSeasonalStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharkSeasonalStats to delete
     */
    where?: SharkSeasonalStatsWhereInput
    /**
     * Limit how many SharkSeasonalStats to delete.
     */
    limit?: number
  }

  /**
   * SharkSeasonalStats without action
   */
  export type SharkSeasonalStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharkSeasonalStats
     */
    select?: SharkSeasonalStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharkSeasonalStats
     */
    omit?: SharkSeasonalStatsOmit<ExtArgs> | null
  }


  /**
   * Model MLModel
   */

  export type AggregateMLModel = {
    _count: MLModelCountAggregateOutputType | null
    _min: MLModelMinAggregateOutputType | null
    _max: MLModelMaxAggregateOutputType | null
  }

  export type MLModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    endpointUrl: string | null
    status: string | null
    createdAt: Date | null
  }

  export type MLModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    endpointUrl: string | null
    status: string | null
    createdAt: Date | null
  }

  export type MLModelCountAggregateOutputType = {
    id: number
    name: number
    version: number
    description: number
    endpointUrl: number
    inputSchema: number
    outputSchema: number
    status: number
    createdAt: number
    _all: number
  }


  export type MLModelMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    endpointUrl?: true
    status?: true
    createdAt?: true
  }

  export type MLModelMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    endpointUrl?: true
    status?: true
    createdAt?: true
  }

  export type MLModelCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    endpointUrl?: true
    inputSchema?: true
    outputSchema?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type MLModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLModel to aggregate.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MLModels
    **/
    _count?: true | MLModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MLModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MLModelMaxAggregateInputType
  }

  export type GetMLModelAggregateType<T extends MLModelAggregateArgs> = {
        [P in keyof T & keyof AggregateMLModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMLModel[P]>
      : GetScalarType<T[P], AggregateMLModel[P]>
  }




  export type MLModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MLModelWhereInput
    orderBy?: MLModelOrderByWithAggregationInput | MLModelOrderByWithAggregationInput[]
    by: MLModelScalarFieldEnum[] | MLModelScalarFieldEnum
    having?: MLModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MLModelCountAggregateInputType | true
    _min?: MLModelMinAggregateInputType
    _max?: MLModelMaxAggregateInputType
  }

  export type MLModelGroupByOutputType = {
    id: string
    name: string
    version: string
    description: string | null
    endpointUrl: string
    inputSchema: JsonValue
    outputSchema: JsonValue
    status: string
    createdAt: Date
    _count: MLModelCountAggregateOutputType | null
    _min: MLModelMinAggregateOutputType | null
    _max: MLModelMaxAggregateOutputType | null
  }

  type GetMLModelGroupByPayload<T extends MLModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MLModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MLModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MLModelGroupByOutputType[P]>
            : GetScalarType<T[P], MLModelGroupByOutputType[P]>
        }
      >
    >


  export type MLModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    endpointUrl?: boolean
    inputSchema?: boolean
    outputSchema?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    endpointUrl?: boolean
    inputSchema?: boolean
    outputSchema?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    endpointUrl?: boolean
    inputSchema?: boolean
    outputSchema?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mLModel"]>

  export type MLModelSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    endpointUrl?: boolean
    inputSchema?: boolean
    outputSchema?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type MLModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version" | "description" | "endpointUrl" | "inputSchema" | "outputSchema" | "status" | "createdAt", ExtArgs["result"]["mLModel"]>

  export type $MLModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MLModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      description: string | null
      endpointUrl: string
      inputSchema: Prisma.JsonValue
      outputSchema: Prisma.JsonValue
      status: string
      createdAt: Date
    }, ExtArgs["result"]["mLModel"]>
    composites: {}
  }

  type MLModelGetPayload<S extends boolean | null | undefined | MLModelDefaultArgs> = $Result.GetResult<Prisma.$MLModelPayload, S>

  type MLModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MLModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MLModelCountAggregateInputType | true
    }

  export interface MLModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MLModel'], meta: { name: 'MLModel' } }
    /**
     * Find zero or one MLModel that matches the filter.
     * @param {MLModelFindUniqueArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MLModelFindUniqueArgs>(args: SelectSubset<T, MLModelFindUniqueArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MLModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MLModelFindUniqueOrThrowArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MLModelFindUniqueOrThrowArgs>(args: SelectSubset<T, MLModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindFirstArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MLModelFindFirstArgs>(args?: SelectSubset<T, MLModelFindFirstArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MLModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindFirstOrThrowArgs} args - Arguments to find a MLModel
     * @example
     * // Get one MLModel
     * const mLModel = await prisma.mLModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MLModelFindFirstOrThrowArgs>(args?: SelectSubset<T, MLModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MLModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MLModels
     * const mLModels = await prisma.mLModel.findMany()
     * 
     * // Get first 10 MLModels
     * const mLModels = await prisma.mLModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MLModelFindManyArgs>(args?: SelectSubset<T, MLModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MLModel.
     * @param {MLModelCreateArgs} args - Arguments to create a MLModel.
     * @example
     * // Create one MLModel
     * const MLModel = await prisma.mLModel.create({
     *   data: {
     *     // ... data to create a MLModel
     *   }
     * })
     * 
     */
    create<T extends MLModelCreateArgs>(args: SelectSubset<T, MLModelCreateArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MLModels.
     * @param {MLModelCreateManyArgs} args - Arguments to create many MLModels.
     * @example
     * // Create many MLModels
     * const mLModel = await prisma.mLModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MLModelCreateManyArgs>(args?: SelectSubset<T, MLModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MLModels and returns the data saved in the database.
     * @param {MLModelCreateManyAndReturnArgs} args - Arguments to create many MLModels.
     * @example
     * // Create many MLModels
     * const mLModel = await prisma.mLModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MLModels and only return the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MLModelCreateManyAndReturnArgs>(args?: SelectSubset<T, MLModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MLModel.
     * @param {MLModelDeleteArgs} args - Arguments to delete one MLModel.
     * @example
     * // Delete one MLModel
     * const MLModel = await prisma.mLModel.delete({
     *   where: {
     *     // ... filter to delete one MLModel
     *   }
     * })
     * 
     */
    delete<T extends MLModelDeleteArgs>(args: SelectSubset<T, MLModelDeleteArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MLModel.
     * @param {MLModelUpdateArgs} args - Arguments to update one MLModel.
     * @example
     * // Update one MLModel
     * const mLModel = await prisma.mLModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MLModelUpdateArgs>(args: SelectSubset<T, MLModelUpdateArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MLModels.
     * @param {MLModelDeleteManyArgs} args - Arguments to filter MLModels to delete.
     * @example
     * // Delete a few MLModels
     * const { count } = await prisma.mLModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MLModelDeleteManyArgs>(args?: SelectSubset<T, MLModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MLModels
     * const mLModel = await prisma.mLModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MLModelUpdateManyArgs>(args: SelectSubset<T, MLModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MLModels and returns the data updated in the database.
     * @param {MLModelUpdateManyAndReturnArgs} args - Arguments to update many MLModels.
     * @example
     * // Update many MLModels
     * const mLModel = await prisma.mLModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MLModels and only return the `id`
     * const mLModelWithIdOnly = await prisma.mLModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MLModelUpdateManyAndReturnArgs>(args: SelectSubset<T, MLModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MLModel.
     * @param {MLModelUpsertArgs} args - Arguments to update or create a MLModel.
     * @example
     * // Update or create a MLModel
     * const mLModel = await prisma.mLModel.upsert({
     *   create: {
     *     // ... data to create a MLModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MLModel we want to update
     *   }
     * })
     */
    upsert<T extends MLModelUpsertArgs>(args: SelectSubset<T, MLModelUpsertArgs<ExtArgs>>): Prisma__MLModelClient<$Result.GetResult<Prisma.$MLModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MLModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelCountArgs} args - Arguments to filter MLModels to count.
     * @example
     * // Count the number of MLModels
     * const count = await prisma.mLModel.count({
     *   where: {
     *     // ... the filter for the MLModels we want to count
     *   }
     * })
    **/
    count<T extends MLModelCountArgs>(
      args?: Subset<T, MLModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MLModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MLModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MLModelAggregateArgs>(args: Subset<T, MLModelAggregateArgs>): Prisma.PrismaPromise<GetMLModelAggregateType<T>>

    /**
     * Group by MLModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MLModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MLModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MLModelGroupByArgs['orderBy'] }
        : { orderBy?: MLModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MLModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMLModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MLModel model
   */
  readonly fields: MLModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MLModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MLModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MLModel model
   */
  interface MLModelFieldRefs {
    readonly id: FieldRef<"MLModel", 'String'>
    readonly name: FieldRef<"MLModel", 'String'>
    readonly version: FieldRef<"MLModel", 'String'>
    readonly description: FieldRef<"MLModel", 'String'>
    readonly endpointUrl: FieldRef<"MLModel", 'String'>
    readonly inputSchema: FieldRef<"MLModel", 'Json'>
    readonly outputSchema: FieldRef<"MLModel", 'Json'>
    readonly status: FieldRef<"MLModel", 'String'>
    readonly createdAt: FieldRef<"MLModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MLModel findUnique
   */
  export type MLModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel findUniqueOrThrow
   */
  export type MLModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel findFirst
   */
  export type MLModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLModels.
     */
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel findFirstOrThrow
   */
  export type MLModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter, which MLModel to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MLModels.
     */
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel findMany
   */
  export type MLModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter, which MLModels to fetch.
     */
    where?: MLModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MLModels to fetch.
     */
    orderBy?: MLModelOrderByWithRelationInput | MLModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MLModels.
     */
    cursor?: MLModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MLModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MLModels.
     */
    skip?: number
    distinct?: MLModelScalarFieldEnum | MLModelScalarFieldEnum[]
  }

  /**
   * MLModel create
   */
  export type MLModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data needed to create a MLModel.
     */
    data: XOR<MLModelCreateInput, MLModelUncheckedCreateInput>
  }

  /**
   * MLModel createMany
   */
  export type MLModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MLModels.
     */
    data: MLModelCreateManyInput | MLModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLModel createManyAndReturn
   */
  export type MLModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data used to create many MLModels.
     */
    data: MLModelCreateManyInput | MLModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MLModel update
   */
  export type MLModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data needed to update a MLModel.
     */
    data: XOR<MLModelUpdateInput, MLModelUncheckedUpdateInput>
    /**
     * Choose, which MLModel to update.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel updateMany
   */
  export type MLModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MLModels.
     */
    data: XOR<MLModelUpdateManyMutationInput, MLModelUncheckedUpdateManyInput>
    /**
     * Filter which MLModels to update
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to update.
     */
    limit?: number
  }

  /**
   * MLModel updateManyAndReturn
   */
  export type MLModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The data used to update MLModels.
     */
    data: XOR<MLModelUpdateManyMutationInput, MLModelUncheckedUpdateManyInput>
    /**
     * Filter which MLModels to update
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to update.
     */
    limit?: number
  }

  /**
   * MLModel upsert
   */
  export type MLModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * The filter to search for the MLModel to update in case it exists.
     */
    where: MLModelWhereUniqueInput
    /**
     * In case the MLModel found by the `where` argument doesn't exist, create a new MLModel with this data.
     */
    create: XOR<MLModelCreateInput, MLModelUncheckedCreateInput>
    /**
     * In case the MLModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MLModelUpdateInput, MLModelUncheckedUpdateInput>
  }

  /**
   * MLModel delete
   */
  export type MLModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
    /**
     * Filter which MLModel to delete.
     */
    where: MLModelWhereUniqueInput
  }

  /**
   * MLModel deleteMany
   */
  export type MLModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MLModels to delete
     */
    where?: MLModelWhereInput
    /**
     * Limit how many MLModels to delete.
     */
    limit?: number
  }

  /**
   * MLModel without action
   */
  export type MLModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MLModel
     */
    select?: MLModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MLModel
     */
    omit?: MLModelOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    key: 'key',
    userId: 'userId',
    revoked: 'revoked',
    createdAt: 'createdAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const DatasetScalarFieldEnum: {
    id: 'id',
    source: 'source',
    type: 'type',
    fileUrl: 'fileUrl',
    ingestionDate: 'ingestionDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatasetScalarFieldEnum = (typeof DatasetScalarFieldEnum)[keyof typeof DatasetScalarFieldEnum]


  export const IngestionJobScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    error: 'error'
  };

  export type IngestionJobScalarFieldEnum = (typeof IngestionJobScalarFieldEnum)[keyof typeof IngestionJobScalarFieldEnum]


  export const ObservationScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    lat: 'lat',
    lon: 'lon',
    chlorophyll: 'chlorophyll',
    sst: 'sst',
    eddyStrength: 'eddyStrength',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type ObservationScalarFieldEnum = (typeof ObservationScalarFieldEnum)[keyof typeof ObservationScalarFieldEnum]


  export const SharkScalarFieldEnum: {
    id: 'id',
    tagId: 'tagId',
    species: 'species',
    sex: 'sex',
    lengthCm: 'lengthCm',
    weightKg: 'weightKg',
    releaseDate: 'releaseDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SharkScalarFieldEnum = (typeof SharkScalarFieldEnum)[keyof typeof SharkScalarFieldEnum]


  export const TrackingDataScalarFieldEnum: {
    id: 'id',
    sharkId: 'sharkId',
    lat: 'lat',
    lon: 'lon',
    timestamp: 'timestamp',
    depth: 'depth',
    temperature: 'temperature',
    eddyId: 'eddyId',
    chlorophyll: 'chlorophyll',
    sst: 'sst',
    createdAt: 'createdAt'
  };

  export type TrackingDataScalarFieldEnum = (typeof TrackingDataScalarFieldEnum)[keyof typeof TrackingDataScalarFieldEnum]


  export const SharkHotspotScalarFieldEnum: {
    id: 'id',
    region: 'region',
    latitude: 'latitude',
    longitude: 'longitude',
    count: 'count',
    avgTemp: 'avgTemp',
    avgChl: 'avgChl',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt'
  };

  export type SharkHotspotScalarFieldEnum = (typeof SharkHotspotScalarFieldEnum)[keyof typeof SharkHotspotScalarFieldEnum]


  export const SharkSeasonalStatsScalarFieldEnum: {
    id: 'id',
    season: 'season',
    totalTags: 'totalTags',
    uniqueSharks: 'uniqueSharks',
    avgSpeed: 'avgSpeed',
    hotspotCount: 'hotspotCount',
    createdAt: 'createdAt'
  };

  export type SharkSeasonalStatsScalarFieldEnum = (typeof SharkSeasonalStatsScalarFieldEnum)[keyof typeof SharkSeasonalStatsScalarFieldEnum]


  export const MLModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    description: 'description',
    endpointUrl: 'endpointUrl',
    inputSchema: 'inputSchema',
    outputSchema: 'outputSchema',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type MLModelScalarFieldEnum = (typeof MLModelScalarFieldEnum)[keyof typeof MLModelScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DatasetStatus'
   */
  export type EnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus'>
    


  /**
   * Reference to a field of type 'DatasetStatus[]'
   */
  export type ListEnumDatasetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatasetStatus[]'>
    


  /**
   * Reference to a field of type 'JobStatus'
   */
  export type EnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus'>
    


  /**
   * Reference to a field of type 'JobStatus[]'
   */
  export type ListEnumJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    apiKeys?: ApiKeyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    apiKeys?: ApiKeyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    key?: StringFilter<"ApiKey"> | string
    userId?: IntFilter<"ApiKey"> | number
    revoked?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: IntFilter<"ApiKey"> | number
    revoked?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "key">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ApiKey"> | number
    key?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: IntWithAggregatesFilter<"ApiKey"> | number
    revoked?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type DatasetWhereInput = {
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    id?: StringFilter<"Dataset"> | string
    source?: StringFilter<"Dataset"> | string
    type?: StringFilter<"Dataset"> | string
    fileUrl?: StringFilter<"Dataset"> | string
    ingestionDate?: DateTimeFilter<"Dataset"> | Date | string
    status?: EnumDatasetStatusFilter<"Dataset"> | $Enums.DatasetStatus
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    jobs?: IngestionJobListRelationFilter
    Observation?: ObservationListRelationFilter
  }

  export type DatasetOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    ingestionDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    jobs?: IngestionJobOrderByRelationAggregateInput
    Observation?: ObservationOrderByRelationAggregateInput
  }

  export type DatasetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DatasetWhereInput | DatasetWhereInput[]
    OR?: DatasetWhereInput[]
    NOT?: DatasetWhereInput | DatasetWhereInput[]
    source?: StringFilter<"Dataset"> | string
    type?: StringFilter<"Dataset"> | string
    fileUrl?: StringFilter<"Dataset"> | string
    ingestionDate?: DateTimeFilter<"Dataset"> | Date | string
    status?: EnumDatasetStatusFilter<"Dataset"> | $Enums.DatasetStatus
    createdAt?: DateTimeFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeFilter<"Dataset"> | Date | string
    jobs?: IngestionJobListRelationFilter
    Observation?: ObservationListRelationFilter
  }, "id">

  export type DatasetOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    ingestionDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatasetCountOrderByAggregateInput
    _max?: DatasetMaxOrderByAggregateInput
    _min?: DatasetMinOrderByAggregateInput
  }

  export type DatasetScalarWhereWithAggregatesInput = {
    AND?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    OR?: DatasetScalarWhereWithAggregatesInput[]
    NOT?: DatasetScalarWhereWithAggregatesInput | DatasetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dataset"> | string
    source?: StringWithAggregatesFilter<"Dataset"> | string
    type?: StringWithAggregatesFilter<"Dataset"> | string
    fileUrl?: StringWithAggregatesFilter<"Dataset"> | string
    ingestionDate?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
    status?: EnumDatasetStatusWithAggregatesFilter<"Dataset"> | $Enums.DatasetStatus
    createdAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dataset"> | Date | string
  }

  export type IngestionJobWhereInput = {
    AND?: IngestionJobWhereInput | IngestionJobWhereInput[]
    OR?: IngestionJobWhereInput[]
    NOT?: IngestionJobWhereInput | IngestionJobWhereInput[]
    id?: StringFilter<"IngestionJob"> | string
    datasetId?: StringFilter<"IngestionJob"> | string
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    error?: StringNullableFilter<"IngestionJob"> | string | null
    dataset?: XOR<DatasetScalarRelationFilter, DatasetWhereInput>
  }

  export type IngestionJobOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    dataset?: DatasetOrderByWithRelationInput
  }

  export type IngestionJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IngestionJobWhereInput | IngestionJobWhereInput[]
    OR?: IngestionJobWhereInput[]
    NOT?: IngestionJobWhereInput | IngestionJobWhereInput[]
    datasetId?: StringFilter<"IngestionJob"> | string
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    error?: StringNullableFilter<"IngestionJob"> | string | null
    dataset?: XOR<DatasetScalarRelationFilter, DatasetWhereInput>
  }, "id">

  export type IngestionJobOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: IngestionJobCountOrderByAggregateInput
    _max?: IngestionJobMaxOrderByAggregateInput
    _min?: IngestionJobMinOrderByAggregateInput
  }

  export type IngestionJobScalarWhereWithAggregatesInput = {
    AND?: IngestionJobScalarWhereWithAggregatesInput | IngestionJobScalarWhereWithAggregatesInput[]
    OR?: IngestionJobScalarWhereWithAggregatesInput[]
    NOT?: IngestionJobScalarWhereWithAggregatesInput | IngestionJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IngestionJob"> | string
    datasetId?: StringWithAggregatesFilter<"IngestionJob"> | string
    status?: EnumJobStatusWithAggregatesFilter<"IngestionJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"IngestionJob"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"IngestionJob"> | string | null
  }

  export type ObservationWhereInput = {
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    id?: StringFilter<"Observation"> | string
    datasetId?: StringFilter<"Observation"> | string
    lat?: FloatFilter<"Observation"> | number
    lon?: FloatFilter<"Observation"> | number
    chlorophyll?: FloatNullableFilter<"Observation"> | number | null
    sst?: FloatNullableFilter<"Observation"> | number | null
    eddyStrength?: FloatNullableFilter<"Observation"> | number | null
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    dataset?: XOR<DatasetScalarRelationFilter, DatasetWhereInput>
  }

  export type ObservationOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrderInput | SortOrder
    sst?: SortOrderInput | SortOrder
    eddyStrength?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    dataset?: DatasetOrderByWithRelationInput
  }

  export type ObservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    datasetId?: StringFilter<"Observation"> | string
    lat?: FloatFilter<"Observation"> | number
    lon?: FloatFilter<"Observation"> | number
    chlorophyll?: FloatNullableFilter<"Observation"> | number | null
    sst?: FloatNullableFilter<"Observation"> | number | null
    eddyStrength?: FloatNullableFilter<"Observation"> | number | null
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    createdAt?: DateTimeFilter<"Observation"> | Date | string
    dataset?: XOR<DatasetScalarRelationFilter, DatasetWhereInput>
  }, "id">

  export type ObservationOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrderInput | SortOrder
    sst?: SortOrderInput | SortOrder
    eddyStrength?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: ObservationCountOrderByAggregateInput
    _avg?: ObservationAvgOrderByAggregateInput
    _max?: ObservationMaxOrderByAggregateInput
    _min?: ObservationMinOrderByAggregateInput
    _sum?: ObservationSumOrderByAggregateInput
  }

  export type ObservationScalarWhereWithAggregatesInput = {
    AND?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    OR?: ObservationScalarWhereWithAggregatesInput[]
    NOT?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Observation"> | string
    datasetId?: StringWithAggregatesFilter<"Observation"> | string
    lat?: FloatWithAggregatesFilter<"Observation"> | number
    lon?: FloatWithAggregatesFilter<"Observation"> | number
    chlorophyll?: FloatNullableWithAggregatesFilter<"Observation"> | number | null
    sst?: FloatNullableWithAggregatesFilter<"Observation"> | number | null
    eddyStrength?: FloatNullableWithAggregatesFilter<"Observation"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
  }

  export type SharkWhereInput = {
    AND?: SharkWhereInput | SharkWhereInput[]
    OR?: SharkWhereInput[]
    NOT?: SharkWhereInput | SharkWhereInput[]
    id?: StringFilter<"Shark"> | string
    tagId?: StringFilter<"Shark"> | string
    species?: StringNullableFilter<"Shark"> | string | null
    sex?: StringNullableFilter<"Shark"> | string | null
    lengthCm?: FloatNullableFilter<"Shark"> | number | null
    weightKg?: FloatNullableFilter<"Shark"> | number | null
    releaseDate?: DateTimeNullableFilter<"Shark"> | Date | string | null
    createdAt?: DateTimeFilter<"Shark"> | Date | string
    updatedAt?: DateTimeFilter<"Shark"> | Date | string
    trackingData?: TrackingDataListRelationFilter
  }

  export type SharkOrderByWithRelationInput = {
    id?: SortOrder
    tagId?: SortOrder
    species?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    lengthCm?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackingData?: TrackingDataOrderByRelationAggregateInput
  }

  export type SharkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagId?: string
    AND?: SharkWhereInput | SharkWhereInput[]
    OR?: SharkWhereInput[]
    NOT?: SharkWhereInput | SharkWhereInput[]
    species?: StringNullableFilter<"Shark"> | string | null
    sex?: StringNullableFilter<"Shark"> | string | null
    lengthCm?: FloatNullableFilter<"Shark"> | number | null
    weightKg?: FloatNullableFilter<"Shark"> | number | null
    releaseDate?: DateTimeNullableFilter<"Shark"> | Date | string | null
    createdAt?: DateTimeFilter<"Shark"> | Date | string
    updatedAt?: DateTimeFilter<"Shark"> | Date | string
    trackingData?: TrackingDataListRelationFilter
  }, "id" | "tagId">

  export type SharkOrderByWithAggregationInput = {
    id?: SortOrder
    tagId?: SortOrder
    species?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    lengthCm?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SharkCountOrderByAggregateInput
    _avg?: SharkAvgOrderByAggregateInput
    _max?: SharkMaxOrderByAggregateInput
    _min?: SharkMinOrderByAggregateInput
    _sum?: SharkSumOrderByAggregateInput
  }

  export type SharkScalarWhereWithAggregatesInput = {
    AND?: SharkScalarWhereWithAggregatesInput | SharkScalarWhereWithAggregatesInput[]
    OR?: SharkScalarWhereWithAggregatesInput[]
    NOT?: SharkScalarWhereWithAggregatesInput | SharkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shark"> | string
    tagId?: StringWithAggregatesFilter<"Shark"> | string
    species?: StringNullableWithAggregatesFilter<"Shark"> | string | null
    sex?: StringNullableWithAggregatesFilter<"Shark"> | string | null
    lengthCm?: FloatNullableWithAggregatesFilter<"Shark"> | number | null
    weightKg?: FloatNullableWithAggregatesFilter<"Shark"> | number | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Shark"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shark"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shark"> | Date | string
  }

  export type TrackingDataWhereInput = {
    AND?: TrackingDataWhereInput | TrackingDataWhereInput[]
    OR?: TrackingDataWhereInput[]
    NOT?: TrackingDataWhereInput | TrackingDataWhereInput[]
    id?: StringFilter<"TrackingData"> | string
    sharkId?: StringFilter<"TrackingData"> | string
    lat?: FloatFilter<"TrackingData"> | number
    lon?: FloatFilter<"TrackingData"> | number
    timestamp?: DateTimeFilter<"TrackingData"> | Date | string
    depth?: FloatNullableFilter<"TrackingData"> | number | null
    temperature?: FloatNullableFilter<"TrackingData"> | number | null
    eddyId?: StringNullableFilter<"TrackingData"> | string | null
    chlorophyll?: FloatNullableFilter<"TrackingData"> | number | null
    sst?: FloatNullableFilter<"TrackingData"> | number | null
    createdAt?: DateTimeFilter<"TrackingData"> | Date | string
    shark?: XOR<SharkScalarRelationFilter, SharkWhereInput>
  }

  export type TrackingDataOrderByWithRelationInput = {
    id?: SortOrder
    sharkId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    timestamp?: SortOrder
    depth?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    eddyId?: SortOrderInput | SortOrder
    chlorophyll?: SortOrderInput | SortOrder
    sst?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    shark?: SharkOrderByWithRelationInput
  }

  export type TrackingDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrackingDataWhereInput | TrackingDataWhereInput[]
    OR?: TrackingDataWhereInput[]
    NOT?: TrackingDataWhereInput | TrackingDataWhereInput[]
    sharkId?: StringFilter<"TrackingData"> | string
    lat?: FloatFilter<"TrackingData"> | number
    lon?: FloatFilter<"TrackingData"> | number
    timestamp?: DateTimeFilter<"TrackingData"> | Date | string
    depth?: FloatNullableFilter<"TrackingData"> | number | null
    temperature?: FloatNullableFilter<"TrackingData"> | number | null
    eddyId?: StringNullableFilter<"TrackingData"> | string | null
    chlorophyll?: FloatNullableFilter<"TrackingData"> | number | null
    sst?: FloatNullableFilter<"TrackingData"> | number | null
    createdAt?: DateTimeFilter<"TrackingData"> | Date | string
    shark?: XOR<SharkScalarRelationFilter, SharkWhereInput>
  }, "id">

  export type TrackingDataOrderByWithAggregationInput = {
    id?: SortOrder
    sharkId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    timestamp?: SortOrder
    depth?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    eddyId?: SortOrderInput | SortOrder
    chlorophyll?: SortOrderInput | SortOrder
    sst?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TrackingDataCountOrderByAggregateInput
    _avg?: TrackingDataAvgOrderByAggregateInput
    _max?: TrackingDataMaxOrderByAggregateInput
    _min?: TrackingDataMinOrderByAggregateInput
    _sum?: TrackingDataSumOrderByAggregateInput
  }

  export type TrackingDataScalarWhereWithAggregatesInput = {
    AND?: TrackingDataScalarWhereWithAggregatesInput | TrackingDataScalarWhereWithAggregatesInput[]
    OR?: TrackingDataScalarWhereWithAggregatesInput[]
    NOT?: TrackingDataScalarWhereWithAggregatesInput | TrackingDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrackingData"> | string
    sharkId?: StringWithAggregatesFilter<"TrackingData"> | string
    lat?: FloatWithAggregatesFilter<"TrackingData"> | number
    lon?: FloatWithAggregatesFilter<"TrackingData"> | number
    timestamp?: DateTimeWithAggregatesFilter<"TrackingData"> | Date | string
    depth?: FloatNullableWithAggregatesFilter<"TrackingData"> | number | null
    temperature?: FloatNullableWithAggregatesFilter<"TrackingData"> | number | null
    eddyId?: StringNullableWithAggregatesFilter<"TrackingData"> | string | null
    chlorophyll?: FloatNullableWithAggregatesFilter<"TrackingData"> | number | null
    sst?: FloatNullableWithAggregatesFilter<"TrackingData"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"TrackingData"> | Date | string
  }

  export type SharkHotspotWhereInput = {
    AND?: SharkHotspotWhereInput | SharkHotspotWhereInput[]
    OR?: SharkHotspotWhereInput[]
    NOT?: SharkHotspotWhereInput | SharkHotspotWhereInput[]
    id?: StringFilter<"SharkHotspot"> | string
    region?: StringFilter<"SharkHotspot"> | string
    latitude?: FloatFilter<"SharkHotspot"> | number
    longitude?: FloatFilter<"SharkHotspot"> | number
    count?: IntFilter<"SharkHotspot"> | number
    avgTemp?: FloatNullableFilter<"SharkHotspot"> | number | null
    avgChl?: FloatNullableFilter<"SharkHotspot"> | number | null
    startTime?: DateTimeFilter<"SharkHotspot"> | Date | string
    endTime?: DateTimeFilter<"SharkHotspot"> | Date | string
    createdAt?: DateTimeFilter<"SharkHotspot"> | Date | string
  }

  export type SharkHotspotOrderByWithRelationInput = {
    id?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrderInput | SortOrder
    avgChl?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkHotspotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharkHotspotWhereInput | SharkHotspotWhereInput[]
    OR?: SharkHotspotWhereInput[]
    NOT?: SharkHotspotWhereInput | SharkHotspotWhereInput[]
    region?: StringFilter<"SharkHotspot"> | string
    latitude?: FloatFilter<"SharkHotspot"> | number
    longitude?: FloatFilter<"SharkHotspot"> | number
    count?: IntFilter<"SharkHotspot"> | number
    avgTemp?: FloatNullableFilter<"SharkHotspot"> | number | null
    avgChl?: FloatNullableFilter<"SharkHotspot"> | number | null
    startTime?: DateTimeFilter<"SharkHotspot"> | Date | string
    endTime?: DateTimeFilter<"SharkHotspot"> | Date | string
    createdAt?: DateTimeFilter<"SharkHotspot"> | Date | string
  }, "id">

  export type SharkHotspotOrderByWithAggregationInput = {
    id?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrderInput | SortOrder
    avgChl?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    _count?: SharkHotspotCountOrderByAggregateInput
    _avg?: SharkHotspotAvgOrderByAggregateInput
    _max?: SharkHotspotMaxOrderByAggregateInput
    _min?: SharkHotspotMinOrderByAggregateInput
    _sum?: SharkHotspotSumOrderByAggregateInput
  }

  export type SharkHotspotScalarWhereWithAggregatesInput = {
    AND?: SharkHotspotScalarWhereWithAggregatesInput | SharkHotspotScalarWhereWithAggregatesInput[]
    OR?: SharkHotspotScalarWhereWithAggregatesInput[]
    NOT?: SharkHotspotScalarWhereWithAggregatesInput | SharkHotspotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharkHotspot"> | string
    region?: StringWithAggregatesFilter<"SharkHotspot"> | string
    latitude?: FloatWithAggregatesFilter<"SharkHotspot"> | number
    longitude?: FloatWithAggregatesFilter<"SharkHotspot"> | number
    count?: IntWithAggregatesFilter<"SharkHotspot"> | number
    avgTemp?: FloatNullableWithAggregatesFilter<"SharkHotspot"> | number | null
    avgChl?: FloatNullableWithAggregatesFilter<"SharkHotspot"> | number | null
    startTime?: DateTimeWithAggregatesFilter<"SharkHotspot"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"SharkHotspot"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SharkHotspot"> | Date | string
  }

  export type SharkSeasonalStatsWhereInput = {
    AND?: SharkSeasonalStatsWhereInput | SharkSeasonalStatsWhereInput[]
    OR?: SharkSeasonalStatsWhereInput[]
    NOT?: SharkSeasonalStatsWhereInput | SharkSeasonalStatsWhereInput[]
    id?: StringFilter<"SharkSeasonalStats"> | string
    season?: StringFilter<"SharkSeasonalStats"> | string
    totalTags?: IntFilter<"SharkSeasonalStats"> | number
    uniqueSharks?: IntFilter<"SharkSeasonalStats"> | number
    avgSpeed?: FloatNullableFilter<"SharkSeasonalStats"> | number | null
    hotspotCount?: IntFilter<"SharkSeasonalStats"> | number
    createdAt?: DateTimeFilter<"SharkSeasonalStats"> | Date | string
  }

  export type SharkSeasonalStatsOrderByWithRelationInput = {
    id?: SortOrder
    season?: SortOrder
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrderInput | SortOrder
    hotspotCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkSeasonalStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharkSeasonalStatsWhereInput | SharkSeasonalStatsWhereInput[]
    OR?: SharkSeasonalStatsWhereInput[]
    NOT?: SharkSeasonalStatsWhereInput | SharkSeasonalStatsWhereInput[]
    season?: StringFilter<"SharkSeasonalStats"> | string
    totalTags?: IntFilter<"SharkSeasonalStats"> | number
    uniqueSharks?: IntFilter<"SharkSeasonalStats"> | number
    avgSpeed?: FloatNullableFilter<"SharkSeasonalStats"> | number | null
    hotspotCount?: IntFilter<"SharkSeasonalStats"> | number
    createdAt?: DateTimeFilter<"SharkSeasonalStats"> | Date | string
  }, "id">

  export type SharkSeasonalStatsOrderByWithAggregationInput = {
    id?: SortOrder
    season?: SortOrder
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrderInput | SortOrder
    hotspotCount?: SortOrder
    createdAt?: SortOrder
    _count?: SharkSeasonalStatsCountOrderByAggregateInput
    _avg?: SharkSeasonalStatsAvgOrderByAggregateInput
    _max?: SharkSeasonalStatsMaxOrderByAggregateInput
    _min?: SharkSeasonalStatsMinOrderByAggregateInput
    _sum?: SharkSeasonalStatsSumOrderByAggregateInput
  }

  export type SharkSeasonalStatsScalarWhereWithAggregatesInput = {
    AND?: SharkSeasonalStatsScalarWhereWithAggregatesInput | SharkSeasonalStatsScalarWhereWithAggregatesInput[]
    OR?: SharkSeasonalStatsScalarWhereWithAggregatesInput[]
    NOT?: SharkSeasonalStatsScalarWhereWithAggregatesInput | SharkSeasonalStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharkSeasonalStats"> | string
    season?: StringWithAggregatesFilter<"SharkSeasonalStats"> | string
    totalTags?: IntWithAggregatesFilter<"SharkSeasonalStats"> | number
    uniqueSharks?: IntWithAggregatesFilter<"SharkSeasonalStats"> | number
    avgSpeed?: FloatNullableWithAggregatesFilter<"SharkSeasonalStats"> | number | null
    hotspotCount?: IntWithAggregatesFilter<"SharkSeasonalStats"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SharkSeasonalStats"> | Date | string
  }

  export type MLModelWhereInput = {
    AND?: MLModelWhereInput | MLModelWhereInput[]
    OR?: MLModelWhereInput[]
    NOT?: MLModelWhereInput | MLModelWhereInput[]
    id?: StringFilter<"MLModel"> | string
    name?: StringFilter<"MLModel"> | string
    version?: StringFilter<"MLModel"> | string
    description?: StringNullableFilter<"MLModel"> | string | null
    endpointUrl?: StringFilter<"MLModel"> | string
    inputSchema?: JsonFilter<"MLModel">
    outputSchema?: JsonFilter<"MLModel">
    status?: StringFilter<"MLModel"> | string
    createdAt?: DateTimeFilter<"MLModel"> | Date | string
  }

  export type MLModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    endpointUrl?: SortOrder
    inputSchema?: SortOrder
    outputSchema?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MLModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MLModelWhereInput | MLModelWhereInput[]
    OR?: MLModelWhereInput[]
    NOT?: MLModelWhereInput | MLModelWhereInput[]
    name?: StringFilter<"MLModel"> | string
    version?: StringFilter<"MLModel"> | string
    description?: StringNullableFilter<"MLModel"> | string | null
    endpointUrl?: StringFilter<"MLModel"> | string
    inputSchema?: JsonFilter<"MLModel">
    outputSchema?: JsonFilter<"MLModel">
    status?: StringFilter<"MLModel"> | string
    createdAt?: DateTimeFilter<"MLModel"> | Date | string
  }, "id">

  export type MLModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrderInput | SortOrder
    endpointUrl?: SortOrder
    inputSchema?: SortOrder
    outputSchema?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: MLModelCountOrderByAggregateInput
    _max?: MLModelMaxOrderByAggregateInput
    _min?: MLModelMinOrderByAggregateInput
  }

  export type MLModelScalarWhereWithAggregatesInput = {
    AND?: MLModelScalarWhereWithAggregatesInput | MLModelScalarWhereWithAggregatesInput[]
    OR?: MLModelScalarWhereWithAggregatesInput[]
    NOT?: MLModelScalarWhereWithAggregatesInput | MLModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MLModel"> | string
    name?: StringWithAggregatesFilter<"MLModel"> | string
    version?: StringWithAggregatesFilter<"MLModel"> | string
    description?: StringNullableWithAggregatesFilter<"MLModel"> | string | null
    endpointUrl?: StringWithAggregatesFilter<"MLModel"> | string
    inputSchema?: JsonWithAggregatesFilter<"MLModel">
    outputSchema?: JsonWithAggregatesFilter<"MLModel">
    status?: StringWithAggregatesFilter<"MLModel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MLModel"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    key: string
    revoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: number
    key: string
    userId: number
    revoked?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: number
    key: string
    userId: number
    revoked?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetCreateInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: IngestionJobCreateNestedManyWithoutDatasetInput
    Observation?: ObservationCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
    Observation?: ObservationUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
    Observation?: ObservationUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
    Observation?: ObservationUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetCreateManyInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatasetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobCreateInput = {
    id?: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
    dataset: DatasetCreateNestedOneWithoutJobsInput
  }

  export type IngestionJobUncheckedCreateInput = {
    id?: string
    datasetId: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
  }

  export type IngestionJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    dataset?: DatasetUpdateOneRequiredWithoutJobsNestedInput
  }

  export type IngestionJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngestionJobCreateManyInput = {
    id?: string
    datasetId: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
  }

  export type IngestionJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngestionJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationCreateInput = {
    id?: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
    dataset: DatasetCreateNestedOneWithoutObservationInput
  }

  export type ObservationUncheckedCreateInput = {
    id?: string
    datasetId: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type ObservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataset?: DatasetUpdateOneRequiredWithoutObservationNestedInput
  }

  export type ObservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationCreateManyInput = {
    id?: string
    datasetId: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type ObservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkCreateInput = {
    id?: string
    tagId: string
    species?: string | null
    sex?: string | null
    lengthCm?: number | null
    weightKg?: number | null
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackingData?: TrackingDataCreateNestedManyWithoutSharkInput
  }

  export type SharkUncheckedCreateInput = {
    id?: string
    tagId: string
    species?: string | null
    sex?: string | null
    lengthCm?: number | null
    weightKg?: number | null
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackingData?: TrackingDataUncheckedCreateNestedManyWithoutSharkInput
  }

  export type SharkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingData?: TrackingDataUpdateManyWithoutSharkNestedInput
  }

  export type SharkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackingData?: TrackingDataUncheckedUpdateManyWithoutSharkNestedInput
  }

  export type SharkCreateManyInput = {
    id?: string
    tagId: string
    species?: string | null
    sex?: string | null
    lengthCm?: number | null
    weightKg?: number | null
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataCreateInput = {
    id?: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
    shark: SharkCreateNestedOneWithoutTrackingDataInput
  }

  export type TrackingDataUncheckedCreateInput = {
    id?: string
    sharkId: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
  }

  export type TrackingDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shark?: SharkUpdateOneRequiredWithoutTrackingDataNestedInput
  }

  export type TrackingDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharkId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataCreateManyInput = {
    id?: string
    sharkId: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
  }

  export type TrackingDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sharkId?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkHotspotCreateInput = {
    id?: string
    region: string
    latitude: number
    longitude: number
    count: number
    avgTemp?: number | null
    avgChl?: number | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type SharkHotspotUncheckedCreateInput = {
    id?: string
    region: string
    latitude: number
    longitude: number
    count: number
    avgTemp?: number | null
    avgChl?: number | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type SharkHotspotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    avgTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    avgChl?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkHotspotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    avgTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    avgChl?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkHotspotCreateManyInput = {
    id?: string
    region: string
    latitude: number
    longitude: number
    count: number
    avgTemp?: number | null
    avgChl?: number | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type SharkHotspotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    avgTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    avgChl?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkHotspotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    avgTemp?: NullableFloatFieldUpdateOperationsInput | number | null
    avgChl?: NullableFloatFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkSeasonalStatsCreateInput = {
    id?: string
    season: string
    totalTags: number
    uniqueSharks: number
    avgSpeed?: number | null
    hotspotCount: number
    createdAt?: Date | string
  }

  export type SharkSeasonalStatsUncheckedCreateInput = {
    id?: string
    season: string
    totalTags: number
    uniqueSharks: number
    avgSpeed?: number | null
    hotspotCount: number
    createdAt?: Date | string
  }

  export type SharkSeasonalStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    totalTags?: IntFieldUpdateOperationsInput | number
    uniqueSharks?: IntFieldUpdateOperationsInput | number
    avgSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    hotspotCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkSeasonalStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    totalTags?: IntFieldUpdateOperationsInput | number
    uniqueSharks?: IntFieldUpdateOperationsInput | number
    avgSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    hotspotCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkSeasonalStatsCreateManyInput = {
    id?: string
    season: string
    totalTags: number
    uniqueSharks: number
    avgSpeed?: number | null
    hotspotCount: number
    createdAt?: Date | string
  }

  export type SharkSeasonalStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    totalTags?: IntFieldUpdateOperationsInput | number
    uniqueSharks?: IntFieldUpdateOperationsInput | number
    avgSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    hotspotCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkSeasonalStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    season?: StringFieldUpdateOperationsInput | string
    totalTags?: IntFieldUpdateOperationsInput | number
    uniqueSharks?: IntFieldUpdateOperationsInput | number
    avgSpeed?: NullableFloatFieldUpdateOperationsInput | number | null
    hotspotCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    endpointUrl: string
    inputSchema: JsonNullValueInput | InputJsonValue
    outputSchema: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type MLModelUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    endpointUrl: string
    inputSchema: JsonNullValueInput | InputJsonValue
    outputSchema: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type MLModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpointUrl?: StringFieldUpdateOperationsInput | string
    inputSchema?: JsonNullValueInput | InputJsonValue
    outputSchema?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpointUrl?: StringFieldUpdateOperationsInput | string
    inputSchema?: JsonNullValueInput | InputJsonValue
    outputSchema?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelCreateManyInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    endpointUrl: string
    inputSchema: JsonNullValueInput | InputJsonValue
    outputSchema: JsonNullValueInput | InputJsonValue
    status?: string
    createdAt?: Date | string
  }

  export type MLModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpointUrl?: StringFieldUpdateOperationsInput | string
    inputSchema?: JsonNullValueInput | InputJsonValue
    outputSchema?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MLModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpointUrl?: StringFieldUpdateOperationsInput | string
    inputSchema?: JsonNullValueInput | InputJsonValue
    outputSchema?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type IngestionJobListRelationFilter = {
    every?: IngestionJobWhereInput
    some?: IngestionJobWhereInput
    none?: IngestionJobWhereInput
  }

  export type ObservationListRelationFilter = {
    every?: ObservationWhereInput
    some?: ObservationWhereInput
    none?: ObservationWhereInput
  }

  export type IngestionJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatasetCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    ingestionDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    ingestionDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatasetMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    type?: SortOrder
    fileUrl?: SortOrder
    ingestionDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type EnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DatasetScalarRelationFilter = {
    is?: DatasetWhereInput
    isNot?: DatasetWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IngestionJobCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type IngestionJobMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type IngestionJobMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type EnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ObservationCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    eddyStrength?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ObservationAvgOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    eddyStrength?: SortOrder
  }

  export type ObservationMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    eddyStrength?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ObservationMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    eddyStrength?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ObservationSumOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    eddyStrength?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type TrackingDataListRelationFilter = {
    every?: TrackingDataWhereInput
    some?: TrackingDataWhereInput
    none?: TrackingDataWhereInput
  }

  export type TrackingDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharkCountOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    species?: SortOrder
    sex?: SortOrder
    lengthCm?: SortOrder
    weightKg?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharkAvgOrderByAggregateInput = {
    lengthCm?: SortOrder
    weightKg?: SortOrder
  }

  export type SharkMaxOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    species?: SortOrder
    sex?: SortOrder
    lengthCm?: SortOrder
    weightKg?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharkMinOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    species?: SortOrder
    sex?: SortOrder
    lengthCm?: SortOrder
    weightKg?: SortOrder
    releaseDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SharkSumOrderByAggregateInput = {
    lengthCm?: SortOrder
    weightKg?: SortOrder
  }

  export type SharkScalarRelationFilter = {
    is?: SharkWhereInput
    isNot?: SharkWhereInput
  }

  export type TrackingDataCountOrderByAggregateInput = {
    id?: SortOrder
    sharkId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    timestamp?: SortOrder
    depth?: SortOrder
    temperature?: SortOrder
    eddyId?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingDataAvgOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    depth?: SortOrder
    temperature?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
  }

  export type TrackingDataMaxOrderByAggregateInput = {
    id?: SortOrder
    sharkId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    timestamp?: SortOrder
    depth?: SortOrder
    temperature?: SortOrder
    eddyId?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingDataMinOrderByAggregateInput = {
    id?: SortOrder
    sharkId?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    timestamp?: SortOrder
    depth?: SortOrder
    temperature?: SortOrder
    eddyId?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
    createdAt?: SortOrder
  }

  export type TrackingDataSumOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
    depth?: SortOrder
    temperature?: SortOrder
    chlorophyll?: SortOrder
    sst?: SortOrder
  }

  export type SharkHotspotCountOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrder
    avgChl?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkHotspotAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrder
    avgChl?: SortOrder
  }

  export type SharkHotspotMaxOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrder
    avgChl?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkHotspotMinOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrder
    avgChl?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkHotspotSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    count?: SortOrder
    avgTemp?: SortOrder
    avgChl?: SortOrder
  }

  export type SharkSeasonalStatsCountOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrder
    hotspotCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkSeasonalStatsAvgOrderByAggregateInput = {
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrder
    hotspotCount?: SortOrder
  }

  export type SharkSeasonalStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrder
    hotspotCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkSeasonalStatsMinOrderByAggregateInput = {
    id?: SortOrder
    season?: SortOrder
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrder
    hotspotCount?: SortOrder
    createdAt?: SortOrder
  }

  export type SharkSeasonalStatsSumOrderByAggregateInput = {
    totalTags?: SortOrder
    uniqueSharks?: SortOrder
    avgSpeed?: SortOrder
    hotspotCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MLModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    endpointUrl?: SortOrder
    inputSchema?: SortOrder
    outputSchema?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MLModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    endpointUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type MLModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    endpointUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type IngestionJobCreateNestedManyWithoutDatasetInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
  }

  export type ObservationCreateNestedManyWithoutDatasetInput = {
    create?: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput> | ObservationCreateWithoutDatasetInput[] | ObservationUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutDatasetInput | ObservationCreateOrConnectWithoutDatasetInput[]
    createMany?: ObservationCreateManyDatasetInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type IngestionJobUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
  }

  export type ObservationUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput> | ObservationCreateWithoutDatasetInput[] | ObservationUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutDatasetInput | ObservationCreateOrConnectWithoutDatasetInput[]
    createMany?: ObservationCreateManyDatasetInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type EnumDatasetStatusFieldUpdateOperationsInput = {
    set?: $Enums.DatasetStatus
  }

  export type IngestionJobUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    upsert?: IngestionJobUpsertWithWhereUniqueWithoutDatasetInput | IngestionJobUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    set?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    disconnect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    delete?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    update?: IngestionJobUpdateWithWhereUniqueWithoutDatasetInput | IngestionJobUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: IngestionJobUpdateManyWithWhereWithoutDatasetInput | IngestionJobUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
  }

  export type ObservationUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput> | ObservationCreateWithoutDatasetInput[] | ObservationUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutDatasetInput | ObservationCreateOrConnectWithoutDatasetInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutDatasetInput | ObservationUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: ObservationCreateManyDatasetInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutDatasetInput | ObservationUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutDatasetInput | ObservationUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput> | IngestionJobCreateWithoutDatasetInput[] | IngestionJobUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: IngestionJobCreateOrConnectWithoutDatasetInput | IngestionJobCreateOrConnectWithoutDatasetInput[]
    upsert?: IngestionJobUpsertWithWhereUniqueWithoutDatasetInput | IngestionJobUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: IngestionJobCreateManyDatasetInputEnvelope
    set?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    disconnect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    delete?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    connect?: IngestionJobWhereUniqueInput | IngestionJobWhereUniqueInput[]
    update?: IngestionJobUpdateWithWhereUniqueWithoutDatasetInput | IngestionJobUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: IngestionJobUpdateManyWithWhereWithoutDatasetInput | IngestionJobUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
  }

  export type ObservationUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput> | ObservationCreateWithoutDatasetInput[] | ObservationUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutDatasetInput | ObservationCreateOrConnectWithoutDatasetInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutDatasetInput | ObservationUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: ObservationCreateManyDatasetInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutDatasetInput | ObservationUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutDatasetInput | ObservationUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type DatasetCreateNestedOneWithoutJobsInput = {
    create?: XOR<DatasetCreateWithoutJobsInput, DatasetUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutJobsInput
    connect?: DatasetWhereUniqueInput
  }

  export type EnumJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.JobStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DatasetUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<DatasetCreateWithoutJobsInput, DatasetUncheckedCreateWithoutJobsInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutJobsInput
    upsert?: DatasetUpsertWithoutJobsInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutJobsInput, DatasetUpdateWithoutJobsInput>, DatasetUncheckedUpdateWithoutJobsInput>
  }

  export type DatasetCreateNestedOneWithoutObservationInput = {
    create?: XOR<DatasetCreateWithoutObservationInput, DatasetUncheckedCreateWithoutObservationInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutObservationInput
    connect?: DatasetWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DatasetUpdateOneRequiredWithoutObservationNestedInput = {
    create?: XOR<DatasetCreateWithoutObservationInput, DatasetUncheckedCreateWithoutObservationInput>
    connectOrCreate?: DatasetCreateOrConnectWithoutObservationInput
    upsert?: DatasetUpsertWithoutObservationInput
    connect?: DatasetWhereUniqueInput
    update?: XOR<XOR<DatasetUpdateToOneWithWhereWithoutObservationInput, DatasetUpdateWithoutObservationInput>, DatasetUncheckedUpdateWithoutObservationInput>
  }

  export type TrackingDataCreateNestedManyWithoutSharkInput = {
    create?: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput> | TrackingDataCreateWithoutSharkInput[] | TrackingDataUncheckedCreateWithoutSharkInput[]
    connectOrCreate?: TrackingDataCreateOrConnectWithoutSharkInput | TrackingDataCreateOrConnectWithoutSharkInput[]
    createMany?: TrackingDataCreateManySharkInputEnvelope
    connect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
  }

  export type TrackingDataUncheckedCreateNestedManyWithoutSharkInput = {
    create?: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput> | TrackingDataCreateWithoutSharkInput[] | TrackingDataUncheckedCreateWithoutSharkInput[]
    connectOrCreate?: TrackingDataCreateOrConnectWithoutSharkInput | TrackingDataCreateOrConnectWithoutSharkInput[]
    createMany?: TrackingDataCreateManySharkInputEnvelope
    connect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
  }

  export type TrackingDataUpdateManyWithoutSharkNestedInput = {
    create?: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput> | TrackingDataCreateWithoutSharkInput[] | TrackingDataUncheckedCreateWithoutSharkInput[]
    connectOrCreate?: TrackingDataCreateOrConnectWithoutSharkInput | TrackingDataCreateOrConnectWithoutSharkInput[]
    upsert?: TrackingDataUpsertWithWhereUniqueWithoutSharkInput | TrackingDataUpsertWithWhereUniqueWithoutSharkInput[]
    createMany?: TrackingDataCreateManySharkInputEnvelope
    set?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    disconnect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    delete?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    connect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    update?: TrackingDataUpdateWithWhereUniqueWithoutSharkInput | TrackingDataUpdateWithWhereUniqueWithoutSharkInput[]
    updateMany?: TrackingDataUpdateManyWithWhereWithoutSharkInput | TrackingDataUpdateManyWithWhereWithoutSharkInput[]
    deleteMany?: TrackingDataScalarWhereInput | TrackingDataScalarWhereInput[]
  }

  export type TrackingDataUncheckedUpdateManyWithoutSharkNestedInput = {
    create?: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput> | TrackingDataCreateWithoutSharkInput[] | TrackingDataUncheckedCreateWithoutSharkInput[]
    connectOrCreate?: TrackingDataCreateOrConnectWithoutSharkInput | TrackingDataCreateOrConnectWithoutSharkInput[]
    upsert?: TrackingDataUpsertWithWhereUniqueWithoutSharkInput | TrackingDataUpsertWithWhereUniqueWithoutSharkInput[]
    createMany?: TrackingDataCreateManySharkInputEnvelope
    set?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    disconnect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    delete?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    connect?: TrackingDataWhereUniqueInput | TrackingDataWhereUniqueInput[]
    update?: TrackingDataUpdateWithWhereUniqueWithoutSharkInput | TrackingDataUpdateWithWhereUniqueWithoutSharkInput[]
    updateMany?: TrackingDataUpdateManyWithWhereWithoutSharkInput | TrackingDataUpdateManyWithWhereWithoutSharkInput[]
    deleteMany?: TrackingDataScalarWhereInput | TrackingDataScalarWhereInput[]
  }

  export type SharkCreateNestedOneWithoutTrackingDataInput = {
    create?: XOR<SharkCreateWithoutTrackingDataInput, SharkUncheckedCreateWithoutTrackingDataInput>
    connectOrCreate?: SharkCreateOrConnectWithoutTrackingDataInput
    connect?: SharkWhereUniqueInput
  }

  export type SharkUpdateOneRequiredWithoutTrackingDataNestedInput = {
    create?: XOR<SharkCreateWithoutTrackingDataInput, SharkUncheckedCreateWithoutTrackingDataInput>
    connectOrCreate?: SharkCreateOrConnectWithoutTrackingDataInput
    upsert?: SharkUpsertWithoutTrackingDataInput
    connect?: SharkWhereUniqueInput
    update?: XOR<XOR<SharkUpdateToOneWithWhereWithoutTrackingDataInput, SharkUpdateWithoutTrackingDataInput>, SharkUncheckedUpdateWithoutTrackingDataInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDatasetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusFilter<$PrismaModel> | $Enums.DatasetStatus
  }

  export type NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatasetStatus | EnumDatasetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatasetStatus[] | ListEnumDatasetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDatasetStatusWithAggregatesFilter<$PrismaModel> | $Enums.DatasetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatasetStatusFilter<$PrismaModel>
    _max?: NestedEnumDatasetStatusFilter<$PrismaModel>
  }

  export type NestedEnumJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusFilter<$PrismaModel> | $Enums.JobStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobStatus | EnumJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobStatus[] | ListEnumJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.JobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobStatusFilter<$PrismaModel>
    _max?: NestedEnumJobStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApiKeyCreateWithoutUserInput = {
    key: string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: number
    key: string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: IntFilter<"ApiKey"> | number
    key?: StringFilter<"ApiKey"> | string
    userId?: IntFilter<"ApiKey"> | number
    revoked?: BoolFilter<"ApiKey"> | boolean
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type UserCreateWithoutApiKeysInput = {
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: number
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobCreateWithoutDatasetInput = {
    id?: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
  }

  export type IngestionJobUncheckedCreateWithoutDatasetInput = {
    id?: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
  }

  export type IngestionJobCreateOrConnectWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    create: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput>
  }

  export type IngestionJobCreateManyDatasetInputEnvelope = {
    data: IngestionJobCreateManyDatasetInput | IngestionJobCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type ObservationCreateWithoutDatasetInput = {
    id?: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type ObservationUncheckedCreateWithoutDatasetInput = {
    id?: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type ObservationCreateOrConnectWithoutDatasetInput = {
    where: ObservationWhereUniqueInput
    create: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput>
  }

  export type ObservationCreateManyDatasetInputEnvelope = {
    data: ObservationCreateManyDatasetInput | ObservationCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type IngestionJobUpsertWithWhereUniqueWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    update: XOR<IngestionJobUpdateWithoutDatasetInput, IngestionJobUncheckedUpdateWithoutDatasetInput>
    create: XOR<IngestionJobCreateWithoutDatasetInput, IngestionJobUncheckedCreateWithoutDatasetInput>
  }

  export type IngestionJobUpdateWithWhereUniqueWithoutDatasetInput = {
    where: IngestionJobWhereUniqueInput
    data: XOR<IngestionJobUpdateWithoutDatasetInput, IngestionJobUncheckedUpdateWithoutDatasetInput>
  }

  export type IngestionJobUpdateManyWithWhereWithoutDatasetInput = {
    where: IngestionJobScalarWhereInput
    data: XOR<IngestionJobUpdateManyMutationInput, IngestionJobUncheckedUpdateManyWithoutDatasetInput>
  }

  export type IngestionJobScalarWhereInput = {
    AND?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
    OR?: IngestionJobScalarWhereInput[]
    NOT?: IngestionJobScalarWhereInput | IngestionJobScalarWhereInput[]
    id?: StringFilter<"IngestionJob"> | string
    datasetId?: StringFilter<"IngestionJob"> | string
    status?: EnumJobStatusFilter<"IngestionJob"> | $Enums.JobStatus
    startedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"IngestionJob"> | Date | string | null
    error?: StringNullableFilter<"IngestionJob"> | string | null
  }

  export type ObservationUpsertWithWhereUniqueWithoutDatasetInput = {
    where: ObservationWhereUniqueInput
    update: XOR<ObservationUpdateWithoutDatasetInput, ObservationUncheckedUpdateWithoutDatasetInput>
    create: XOR<ObservationCreateWithoutDatasetInput, ObservationUncheckedCreateWithoutDatasetInput>
  }

  export type ObservationUpdateWithWhereUniqueWithoutDatasetInput = {
    where: ObservationWhereUniqueInput
    data: XOR<ObservationUpdateWithoutDatasetInput, ObservationUncheckedUpdateWithoutDatasetInput>
  }

  export type ObservationUpdateManyWithWhereWithoutDatasetInput = {
    where: ObservationScalarWhereInput
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyWithoutDatasetInput>
  }

  export type ObservationScalarWhereInput = {
    AND?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    OR?: ObservationScalarWhereInput[]
    NOT?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    id?: StringFilter<"Observation"> | string
    datasetId?: StringFilter<"Observation"> | string
    lat?: FloatFilter<"Observation"> | number
    lon?: FloatFilter<"Observation"> | number
    chlorophyll?: FloatNullableFilter<"Observation"> | number | null
    sst?: FloatNullableFilter<"Observation"> | number | null
    eddyStrength?: FloatNullableFilter<"Observation"> | number | null
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    createdAt?: DateTimeFilter<"Observation"> | Date | string
  }

  export type DatasetCreateWithoutJobsInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Observation?: ObservationCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateWithoutJobsInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Observation?: ObservationUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetCreateOrConnectWithoutJobsInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutJobsInput, DatasetUncheckedCreateWithoutJobsInput>
  }

  export type DatasetUpsertWithoutJobsInput = {
    update: XOR<DatasetUpdateWithoutJobsInput, DatasetUncheckedUpdateWithoutJobsInput>
    create: XOR<DatasetCreateWithoutJobsInput, DatasetUncheckedCreateWithoutJobsInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutJobsInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutJobsInput, DatasetUncheckedUpdateWithoutJobsInput>
  }

  export type DatasetUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Observation?: ObservationUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Observation?: ObservationUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetCreateWithoutObservationInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: IngestionJobCreateNestedManyWithoutDatasetInput
  }

  export type DatasetUncheckedCreateWithoutObservationInput = {
    id?: string
    source: string
    type: string
    fileUrl: string
    ingestionDate?: Date | string
    status?: $Enums.DatasetStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: IngestionJobUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type DatasetCreateOrConnectWithoutObservationInput = {
    where: DatasetWhereUniqueInput
    create: XOR<DatasetCreateWithoutObservationInput, DatasetUncheckedCreateWithoutObservationInput>
  }

  export type DatasetUpsertWithoutObservationInput = {
    update: XOR<DatasetUpdateWithoutObservationInput, DatasetUncheckedUpdateWithoutObservationInput>
    create: XOR<DatasetCreateWithoutObservationInput, DatasetUncheckedCreateWithoutObservationInput>
    where?: DatasetWhereInput
  }

  export type DatasetUpdateToOneWithWhereWithoutObservationInput = {
    where?: DatasetWhereInput
    data: XOR<DatasetUpdateWithoutObservationInput, DatasetUncheckedUpdateWithoutObservationInput>
  }

  export type DatasetUpdateWithoutObservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: IngestionJobUpdateManyWithoutDatasetNestedInput
  }

  export type DatasetUncheckedUpdateWithoutObservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    ingestionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumDatasetStatusFieldUpdateOperationsInput | $Enums.DatasetStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: IngestionJobUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type TrackingDataCreateWithoutSharkInput = {
    id?: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
  }

  export type TrackingDataUncheckedCreateWithoutSharkInput = {
    id?: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
  }

  export type TrackingDataCreateOrConnectWithoutSharkInput = {
    where: TrackingDataWhereUniqueInput
    create: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput>
  }

  export type TrackingDataCreateManySharkInputEnvelope = {
    data: TrackingDataCreateManySharkInput | TrackingDataCreateManySharkInput[]
    skipDuplicates?: boolean
  }

  export type TrackingDataUpsertWithWhereUniqueWithoutSharkInput = {
    where: TrackingDataWhereUniqueInput
    update: XOR<TrackingDataUpdateWithoutSharkInput, TrackingDataUncheckedUpdateWithoutSharkInput>
    create: XOR<TrackingDataCreateWithoutSharkInput, TrackingDataUncheckedCreateWithoutSharkInput>
  }

  export type TrackingDataUpdateWithWhereUniqueWithoutSharkInput = {
    where: TrackingDataWhereUniqueInput
    data: XOR<TrackingDataUpdateWithoutSharkInput, TrackingDataUncheckedUpdateWithoutSharkInput>
  }

  export type TrackingDataUpdateManyWithWhereWithoutSharkInput = {
    where: TrackingDataScalarWhereInput
    data: XOR<TrackingDataUpdateManyMutationInput, TrackingDataUncheckedUpdateManyWithoutSharkInput>
  }

  export type TrackingDataScalarWhereInput = {
    AND?: TrackingDataScalarWhereInput | TrackingDataScalarWhereInput[]
    OR?: TrackingDataScalarWhereInput[]
    NOT?: TrackingDataScalarWhereInput | TrackingDataScalarWhereInput[]
    id?: StringFilter<"TrackingData"> | string
    sharkId?: StringFilter<"TrackingData"> | string
    lat?: FloatFilter<"TrackingData"> | number
    lon?: FloatFilter<"TrackingData"> | number
    timestamp?: DateTimeFilter<"TrackingData"> | Date | string
    depth?: FloatNullableFilter<"TrackingData"> | number | null
    temperature?: FloatNullableFilter<"TrackingData"> | number | null
    eddyId?: StringNullableFilter<"TrackingData"> | string | null
    chlorophyll?: FloatNullableFilter<"TrackingData"> | number | null
    sst?: FloatNullableFilter<"TrackingData"> | number | null
    createdAt?: DateTimeFilter<"TrackingData"> | Date | string
  }

  export type SharkCreateWithoutTrackingDataInput = {
    id?: string
    tagId: string
    species?: string | null
    sex?: string | null
    lengthCm?: number | null
    weightKg?: number | null
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharkUncheckedCreateWithoutTrackingDataInput = {
    id?: string
    tagId: string
    species?: string | null
    sex?: string | null
    lengthCm?: number | null
    weightKg?: number | null
    releaseDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SharkCreateOrConnectWithoutTrackingDataInput = {
    where: SharkWhereUniqueInput
    create: XOR<SharkCreateWithoutTrackingDataInput, SharkUncheckedCreateWithoutTrackingDataInput>
  }

  export type SharkUpsertWithoutTrackingDataInput = {
    update: XOR<SharkUpdateWithoutTrackingDataInput, SharkUncheckedUpdateWithoutTrackingDataInput>
    create: XOR<SharkCreateWithoutTrackingDataInput, SharkUncheckedCreateWithoutTrackingDataInput>
    where?: SharkWhereInput
  }

  export type SharkUpdateToOneWithWhereWithoutTrackingDataInput = {
    where?: SharkWhereInput
    data: XOR<SharkUpdateWithoutTrackingDataInput, SharkUncheckedUpdateWithoutTrackingDataInput>
  }

  export type SharkUpdateWithoutTrackingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharkUncheckedUpdateWithoutTrackingDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    species?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    lengthCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: number
    key: string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    key?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngestionJobCreateManyDatasetInput = {
    id?: string
    status?: $Enums.JobStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    error?: string | null
  }

  export type ObservationCreateManyDatasetInput = {
    id?: string
    lat: number
    lon: number
    chlorophyll?: number | null
    sst?: number | null
    eddyStrength?: number | null
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type IngestionJobUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngestionJobUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngestionJobUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumJobStatusFieldUpdateOperationsInput | $Enums.JobStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ObservationUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyStrength?: NullableFloatFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataCreateManySharkInput = {
    id?: string
    lat: number
    lon: number
    timestamp: Date | string
    depth?: number | null
    temperature?: number | null
    eddyId?: string | null
    chlorophyll?: number | null
    sst?: number | null
    createdAt?: Date | string
  }

  export type TrackingDataUpdateWithoutSharkInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataUncheckedUpdateWithoutSharkInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrackingDataUncheckedUpdateManyWithoutSharkInput = {
    id?: StringFieldUpdateOperationsInput | string
    lat?: FloatFieldUpdateOperationsInput | number
    lon?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    depth?: NullableFloatFieldUpdateOperationsInput | number | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    eddyId?: NullableStringFieldUpdateOperationsInput | string | null
    chlorophyll?: NullableFloatFieldUpdateOperationsInput | number | null
    sst?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}